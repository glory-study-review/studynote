const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":44,\"nextId\":44,\"documentIds\":{\"0\":\"0\",\"1\":\"0#本站内容\",\"2\":\"1\",\"3\":\"1#lock-源码分析\",\"4\":\"1#trylock-源码分析\",\"5\":\"1#unlock-源码分析\",\"6\":\"2\",\"7\":\"3\",\"8\":\"3#spring-aop中几个主要接口和类\",\"9\":\"3#pointcut\",\"10\":\"3#advice\",\"11\":\"3#advisor\",\"12\":\"3#织入器\",\"13\":\"3#aop代理执行过程\",\"14\":\"3#jdkdynamicaopproxy的invoke\",\"15\":\"3#获取拦截器链\",\"16\":\"3#拦截器链调用\",\"17\":\"3#通知类的排序\",\"18\":\"3#第一次排序\",\"19\":\"3#第二次排序\",\"20\":\"4\",\"21\":\"4#五种失效情况\",\"22\":\"4#传播行为\",\"23\":\"4#spring事务源码分析\",\"24\":\"4#多线程下事务的处理\",\"25\":\"5\",\"26\":\"5#解决循环依赖的简单思路\",\"27\":\"5#spring是如何解决循环依赖的\",\"28\":\"5#dogetbean\",\"29\":\"5#docreatebean\",\"30\":\"5#为什么一级缓存不行\",\"31\":\"5#为什么二级缓存不够\",\"32\":\"5#spring无法解决的循环依赖\",\"33\":\"5#构造器注入的循环依赖无法解决\",\"34\":\"5#使用-async\",\"35\":\"6\",\"36\":\"7\",\"37\":\"8\",\"38\":\"9\",\"39\":\"9#路由装配过程\",\"40\":\"10\",\"41\":\"11\",\"42\":\"12\",\"43\":\"13\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,12],\"1\":[1,4],\"2\":[1],\"3\":[2,225],\"4\":[2,154],\"5\":[2,223],\"6\":[1],\"7\":[2],\"8\":[2],\"9\":[1,43],\"10\":[1,10],\"11\":[1,70],\"12\":[1,38],\"13\":[1,5],\"14\":[2,20],\"15\":[1,126],\"16\":[1,197],\"17\":[1],\"18\":[1,38],\"19\":[1,92],\"20\":[1],\"21\":[1,38],\"22\":[1,44],\"23\":[1,189],\"24\":[1,74],\"25\":[1,37],\"26\":[1,84],\"27\":[1,142],\"28\":[2,39],\"29\":[2,184],\"30\":[1,20],\"31\":[1,14],\"32\":[1],\"33\":[1,4],\"34\":[2,37],\"35\":[1],\"36\":[1,19],\"37\":[1],\"38\":[1],\"39\":[1,109],\"40\":[1,3],\"41\":[1],\"42\":[1],\"43\":[1]},\"averageFieldLength\":[1.2045454545454546,75.51419321914659],\"storedFields\":{\"0\":{\"h\":\"导读\",\"t\":[\"提示\",\"自学和工作期间有着记录笔记的习惯，由于时间碎片化，笔记的内容混杂在多个本地文档中，因此想整理补充形成目录较分明的文档。\",\"网上有许多知识分享网站使用Vuepress构建，于是自己也尝试使用，空余时间将本地笔记慢慢整理至此\",\"所有内容都是本人查阅资料后的个人理解，可能存在着理解错误之处，注意甄别！\"]},\"1\":{\"h\":\"本站内容\",\"t\":[\"Spring相关内容\",\"SpringBoot相关内容\",\"SpringCloud相关内容\",\"Redisson\"]},\"2\":{\"h\":\"Redisson分布锁实现\"},\"3\":{\"h\":\"lock()源码分析\",\"t\":[\"lock()是由RedissonLock类实现的方法，查看源码\",\"调用了private void lock(long leaseTime, TimeUnit unit, boolean interruptibly) 重载方法\",\"private void lock(long leaseTime, TimeUnit unit, boolean interruptibly) throws InterruptedException { long threadId = Thread.currentThread().getId(); Long ttl = tryAcquire(-1, leaseTime, unit, threadId); // lock acquired if (ttl == null) { //获取锁成功，结束方法 return; } //异步订阅解锁消息 CompletableFuture<RedissonLockEntry> future = subscribe(threadId); // 设置定时任务，达到超时处理 // 定时任务内容为，订阅解锁消息的任务 没完成抛出指定异常 // 如果定时任务启动前 完成的话会取消这个定时任务 pubSub.timeout(future); //阻塞等待解锁消息 RedissonLockEntry entry; if (interruptibly) { //可中断 entry = commandExecutor.getInterrupted(future); } else { //不可中断，阻塞等待 entry = commandExecutor.get(future); } try { //不断尝试获取锁 知道产生中断或者获取到锁 while (true) { ttl = tryAcquire(-1, leaseTime, unit, threadId); // lock acquired if (ttl == null) { break; } // waiting for message // 没有获取到锁，会阻塞ttl的时间，期间如果锁被释放，或者当前线程被中断，或者阻塞时间到了，再继续 if (ttl >= 0) { try { entry.getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { if (interruptibly) { throw e; } entry.getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS); } } else { if (interruptibly) { entry.getLatch().acquire(); } else { entry.getLatch().acquireUninterruptibly(); } } } } finally { //最终释放订阅 unsubscribe(entry, threadId); } } \",\"tryAcquire(long waitTime, long leaseTime, TimeUnit unit, long threadId)，参数分别为超时时间、锁过期时间、时间单位、当前尝试获取锁id\",\"tryAcquireAsync0(long waitTime, long leaseTime, TimeUnit unit, long threadId)\",\"尝试获取锁\",\"如果lock()方法没有设置过期时间，默认leaseTime为-1，可以从述代码中看到，没有设置过期时间，会默认传入internalLockLeaseTime值为30000ms\",\"private RFuture<Long> tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) { RFuture<Long> ttlRemainingFuture; if (leaseTime > 0) { //用户设置了过期时间 ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG); } else { //用户未设置过期时间,默认使用internalLockLeaseTime，初始值为30000ms ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime, TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG); } CompletionStage<Long> s = handleNoSync(threadId, ttlRemainingFuture); ttlRemainingFuture = new CompletableFutureWrapper<>(s); CompletionStage<Long> f = ttlRemainingFuture.thenApply(ttlRemaining -> { // lua执行结果 获取为null 说明加锁成功 if (ttlRemaining == null) { if (leaseTime > 0) { // 成功后，如果用户未设置过期时间，更新internalLockLeaseTime为用户设定时间 // 保证重入锁并且用户未设置过期时间时延用初始的过期时间 internalLockLeaseTime = unit.toMillis(leaseTime); } else { // 设置定时任务，按过期时间的1/3时间频率续期，续期时间值 internalLockLeaseTime 决定 scheduleExpirationRenewal(threadId); } } return ttlRemaining; }); return new CompletableFutureWrapper<>(f); } \",\"获取锁底层使用的lua脚本，将获取锁对象时的name参数作为KEYS传入，过期时间和当前线程标识作为ARGV传入；\",\"<T> RFuture<T> tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) { return evalWriteSyncedAsync(getRawName(), LongCodec.INSTANCE, command, \\\"if ((redis.call('exists', KEYS[1]) == 0) \\\" + \\\"or (redis.call('hexists', KEYS[1], ARGV[2]) == 1)) then \\\" + \\\"redis.call('hincrby', KEYS[1], ARGV[2], 1); \\\" + \\\"redis.call('pexpire', KEYS[1], ARGV[1]); \\\" + \\\"return nil; \\\" + \\\"end; \\\" + \\\"return redis.call('pttl', KEYS[1]);\\\", Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId)); } \",\"KEYS[1] -- key ARGV[1] -- 过期时间 ARGV[2] -- field 线程标识 if (redis.call('exists', KEYS[1]) == 0) or (redis.call('hexists', KEYS[1], ARGV[2]) == 1)) then -- 锁如果不存在 或者 锁存在并且是当前线程的(通过查看key、feild对应的value是否存在) redis.call('hincrby', KEYS[1], ARGV[2], 1); -- 将hash结构的value增1，即重入次数+1 redis.call('pexpire', KEYS[1], ARGV[1]); -- 设置过期时间 return nil; -- 返回nil end; return redis.call('pttl', KEYS[1]); -- 锁存在 且 不是的当前线程的 获取锁失败 返回锁的剩余过期时间 \",\"获取锁成功后，如果未设置过期时间会通过scheduleExpirationRenewal开启了定时任务续期\",\"private void renewExpiration() { ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName()); if (ee == null) { return; } // 内部使用 HashedWheelTimer的newTimeout 开启 定时任务 internalLockLeaseTime/3 毫秒后 执行一次TimerTask内容 Timeout task = getServiceManager().newTimeout(new TimerTask() { @Override public void run(Timeout timeout) throws Exception { ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName()); if (ent == null) { return; } Long threadId = ent.getFirstThreadId(); if (threadId == null) { return; } //开启异步续期 CompletionStage<Boolean> future = renewExpirationAsync(threadId); future.whenComplete((res, e) -> { if (e != null) { log.error(\\\"Can't update lock {} expiration\\\", getRawName(), e); EXPIRATION_RENEWAL_MAP.remove(getEntryName()); return; } if (res) { // reschedule itself // 每次续期任务执行后，又会调用该方法创建好下一次的定时续期任务，达到不断续期效果 renewExpiration(); } else { cancelExpirationRenewal(null, null); } }); } }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS); ee.setTimeout(task); } \",\"续期底层调用RedissonBaseLock的renewExpirationAsync方法\",\"protected CompletionStage<Boolean> renewExpirationAsync(long threadId) { return evalWriteSyncedAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, \\\"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \\\" + \\\"redis.call('pexpire', KEYS[1], ARGV[1]); \\\" + \\\"return 1; \\\" + \\\"end; \\\" + \\\"return 0;\\\", Collections.singletonList(getRawName()), internalLockLeaseTime, getLockName(threadId)); } \"]},\"4\":{\"h\":\"tryLock()源码分析\",\"t\":[\"不带参数的tryLock()方法，最终通过tryAcquireOnceAsync方法，该方法和tryAcquireAsync类似，只是改方法只给tryLock()使用，并且都是没有自定义过期时间的参数\",\"获取锁还是调用的和lock方法一样的tryLockInnerAsync方法，\",\"tryLock()方法内部没有重试，直接返回获取锁的成功与否。\",\"@Override public boolean tryLock() { return get(tryLockAsync()); } @Override public RFuture<Boolean> tryLockAsync(long threadId) { return getServiceManager().execute(() -> tryAcquireOnceAsync(-1, -1, null, threadId)); } private RFuture<Boolean> tryAcquireOnceAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) { CompletionStage<Boolean> acquiredFuture; if (leaseTime > 0) { acquiredFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN); } else { acquiredFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime, TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_NULL_BOOLEAN); } acquiredFuture = handleNoSync(threadId, acquiredFuture); CompletionStage<Boolean> f = acquiredFuture.thenApply(acquired -> { // lock acquired if (acquired) { if (leaseTime > 0) { internalLockLeaseTime = unit.toMillis(leaseTime); } else { scheduleExpirationRenewal(threadId); } } return acquired; }); return new CompletableFutureWrapper<>(f); } \",\"再来看一下带参数的tryLock(long waitTime, long leaseTime, TimeUnit unit)，大致逻辑和lock一致，增加了 锁重试时间的限制，来避免不断重试获取锁的开销\",\"@Override public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException { //重试等待时间 long time = unit.toMillis(waitTime); //当前时间 long current = System.currentTimeMillis(); long threadId = Thread.currentThread().getId(); //获取锁，和lock调用相同的方法 Long ttl = tryAcquire(waitTime, leaseTime, unit, threadId); // lock acquired if (ttl == null) { // 获取到锁 返回true return true; } //更新等待时间 原重试等待时间 - 上面获取锁代码耗时 time -= System.currentTimeMillis() - current; if (time <= 0) { //如果超过了重试等待时时间 返回获取锁失败结果 false acquireFailed(waitTime, unit, threadId); return false; } //再次获取时间 current = System.currentTimeMillis(); //订阅解锁消息 CompletableFuture<RedissonLockEntry> subscribeFuture = subscribe(threadId); try { //阻塞等待解锁消息，阻塞时间就是剩余的等待时间 subscribeFuture.get(time, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { // get阻塞时间到了任务还未完成 抛出TimeoutException // completeExceptionally 如果任务未完成 将任务变为完成状态 并且结果是抛出指定异常； // 如果completeExceptionally的转变完成状态成功，返回true，否则false // 此处如果转变完成状态时任务刚好完成了，那就false if条件成立，随后取消订阅 if (!subscribeFuture.completeExceptionally(new RedisTimeoutException( \\\"Unable to acquire subscription lock after \\\" + time + \\\"ms. \\\" + \\\"Try to increase 'subscriptionsPerConnection' and/or 'subscriptionConnectionPoolSize' parameters.\\\"))) { subscribeFuture.whenComplete((res, ex) -> { if (ex == null) { //取消订阅 unsubscribe(res, threadId); } }); } acquireFailed(waitTime, unit, threadId); return false; } catch (ExecutionException e) { LOGGER.error(e.getMessage(), e); acquireFailed(waitTime, unit, threadId); return false; } try { //再次更新重试等待时间，并查看 time -= System.currentTimeMillis() - current; if (time <= 0) { acquireFailed(waitTime, unit, threadId); return false; } //持续获取锁，知道获取锁成功 或者 重试时间超时 while (true) { long currentTime = System.currentTimeMillis(); ttl = tryAcquire(waitTime, leaseTime, unit, threadId); // lock acquired if (ttl == null) { return true; } time -= System.currentTimeMillis() - currentTime; if (time <= 0) { acquireFailed(waitTime, unit, threadId); return false; } // waiting for message // 重试中，还通过阻塞锁剩余ttl 来避免线程不必要的尝试造成性能浪费 currentTime = System.currentTimeMillis(); if (ttl >= 0 && ttl < time) { commandExecutor.getNow(subscribeFuture).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS); } else { commandExecutor.getNow(subscribeFuture).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS); } time -= System.currentTimeMillis() - currentTime; if (time <= 0) { acquireFailed(waitTime, unit, threadId); return false; } } } finally { unsubscribe(commandExecutor.getNow(subscribeFuture), threadId); } } \"]},\"5\":{\"h\":\"unlock()源码分析\",\"t\":[\"unlock()是RedissonLock的父类RedissonBaseLock的方法，底层解锁处理由RedissonLock的unlockInnerAsync方法实现\",\"unlock() -> unlockAsync() -> unlockAsync0() -> unlockInnerAsync(long threadId) -> unlockInnerAsync(long threadId, String requestId, int timeout)\",\"@Override public void unlock() { try { get(unlockAsync(Thread.currentThread().getId())); } catch (RedisException e) { if (e.getCause() instanceof IllegalMonitorStateException) { throw (IllegalMonitorStateException) e.getCause(); } else { throw e; } } } @Override public RFuture<Void> unlockAsync(long threadId) { return getServiceManager().execute(() -> unlockAsync0(threadId)); } private RFuture<Void> unlockAsync0(long threadId) { CompletionStage<Boolean> future = unlockInnerAsync(threadId); CompletionStage<Void> f = future.handle((res, e) -> { cancelExpirationRenewal(threadId, res); if (e != null) { if (e instanceof CompletionException) { throw (CompletionException) e; } throw new CompletionException(e); } if (res == null) { IllegalMonitorStateException cause = new IllegalMonitorStateException(\\\"attempt to unlock lock, not locked by current thread by node id: \\\" + id + \\\" thread-id: \\\" + threadId); throw new CompletionException(cause); } return null; }); return new CompletableFutureWrapper<>(f); } protected final RFuture<Boolean> unlockInnerAsync(long threadId) { String id = getServiceManager().generateId(); MasterSlaveServersConfig config = getServiceManager().getConfig(); int timeout = (config.getTimeout() + config.getRetryInterval()) * config.getRetryAttempts(); timeout = Math.max(timeout, 1); //解锁 RFuture<Boolean> r = unlockInnerAsync(threadId, id, timeout); CompletionStage<Boolean> ff = r.thenApply(v -> { CommandAsyncExecutor ce = commandExecutor; if (ce instanceof CommandBatchService) { ce = new CommandBatchService(commandExecutor); } ce.writeAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.DEL, getUnlockLatchName(id)); if (ce instanceof CommandBatchService) { ((CommandBatchService) ce).executeAsync(); } return v; }); return new CompletableFutureWrapper<>(ff); } \",\"protected RFuture<Boolean> unlockInnerAsync(long threadId, String requestId, int timeout) { return evalWriteSyncedAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, \\\"local val = redis.call('get', KEYS[3]); \\\" + \\\"if val ~= false then \\\" + \\\"return tonumber(val);\\\" + \\\"end; \\\" + \\\"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then \\\" + \\\"return nil;\\\" + \\\"end; \\\" + \\\"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); \\\" + \\\"if (counter > 0) then \\\" + \\\"redis.call('pexpire', KEYS[1], ARGV[2]); \\\" + \\\"redis.call('set', KEYS[3], 0, 'px', ARGV[5]); \\\" + \\\"return 0; \\\" + \\\"else \\\" + \\\"redis.call('del', KEYS[1]); \\\" + \\\"redis.call(ARGV[4], KEYS[2], ARGV[1]); \\\" + \\\"redis.call('set', KEYS[3], 1, 'px', ARGV[5]); \\\" + \\\"return 1; \\\" + \\\"end; \\\", Arrays.asList(getRawName(), getChannelName(), getUnlockLatchName(requestId)), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId), getSubscribeService().getPublishCommand(), timeout); } \",\"分析一下解锁lua脚本\",\"KEY[1] --锁标识 KEY[2] --发布解锁消息通道 KEY[3] --解锁标识 ARGV[1] --解锁消息 ARGV[2] --过期时间 ARGV[3] --线程标识 ARGV[4] --发布消息命令 PUBLISH SPUBLISH ARGV[5] --超时时间 由(redis客户端响应超时时间[3000ms] + redis客户端重试时间间隔[1500ms]) * redis客户端重试次数[3次] 计算得到 -- 首先判断解锁标识 如果成功获取 就将其转换为数字返回 也表示解锁成功 local val = redis.call('get', KEYS[3]); if val ~= false then return tonumber(val); end; -- 判断当前锁当前线程是否存在 不存在返回null if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then return nil; end; -- 存在，将value-1 扣减一次重入次数 local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); -- 如果次数还大于零，说明当前线程还有方法获取着当前锁，将锁续期一下 并且设置一下解锁标识和过期时间 if (counter > 0) then redis.call('pexpire', KEYS[1], ARGV[2]); redis.call('set', KEYS[3], 0, 'px', ARGV[5]); return 0; else -- 如果次数小于等于零，说明当前线程已经完全释放了锁，将锁删除，发布解锁消息，通知其他线程可以尝试获取锁 -- 设置一下解锁标识和过期时间 redis.call('del', KEYS[1]); redis.call(ARGV[4], KEYS[2], ARGV[1]); redis.call('set', KEYS[3], 1, 'px', ARGV[5]); return 1; end; \",\"判断解锁标识 和 设置解锁标识这段逻辑是 Redisson3.24.1 为了修复以下问题时添加的\",\"Releasing the lock when the lock is determined to be acquired. Why does this error occur? IllegalMonitorStateException - Attempt to unlock read lock, not locked by current thread #4871\",\"这个问题的提出者，遇到的问题是：\",\"当前获取了锁的线程在解锁时，抛出了IllegalMonitorStateException - Attempt to unlock read lock, not locked by current thread异常\",\"开发者没有给出解释\",\"此处我也十分不理解，他的操作也是正常尝试获取锁成功后，执行业务逻辑，最后解锁，代码没有问题。\",\"从这个解锁标识的超时时间的计算发现，这个解锁标识的设置时间是Redisson的Redis客户端(RedisExecutor)重试发送命令的默认最长时间间隔，也就是redis客户端如果存在服务端响应超时，会根据设置的时间重新发送3次。\",\"假设当前持有锁的线程发起解锁lua脚本的执行，可能因为网络或者发送性能等原因没有在给定时间内得到服务端回复，于是客户端再次发起解锁命令的执行，但是前一次的命令已经被redis执行删除了锁，第二次的命令(如果就加了一次锁)就会判断锁不存在了，正常返回null给客户端，客户端在解锁后的逻辑处理中会检查解锁任务的结果，如果是null，就会IllegalMonitorStateException异常，那#4871的问题出现就能解释了。\",\"而解锁标识的设置和过期事件值，保证了服务端只要删除了一次锁，客户端在最长重试时间内，多次的删除锁命令都会得到删除成功，保证命令结果一致性。\"]},\"6\":{\"h\":\"Spring\"},\"7\":{\"h\":\"Spring AOP\"},\"8\":{\"h\":\"Spring AOP中几个主要接口和类\"},\"9\":{\"h\":\"PointCut\",\"t\":[\"AOP切点在Spring中的对象\",\"主要用于 查找匹配 相应的Joinpoint，匹配又分ClassFilter匹配对象和MethodMatcher匹配方法\",\"public interface Pointcut { /** * Return the ClassFilter for this pointcut. * @return the ClassFilter (never {@code null}) */ ClassFilter getClassFilter(); /** * Return the MethodMatcher for this pointcut. * @return the MethodMatcher (never {@code null}) */ MethodMatcher getMethodMatcher(); /** * Canonical Pointcut instance that always matches. */ Pointcut TRUE = TruePointcut.INSTANCE; } \",\"常见的几个实现类JdkRegexpMethodPointcut、NameMatchMethodPointcut、AnnotationMatchingPointcut\",\"JdkRegexpMethodPointcut 通过正则表达式对方法名进行匹配\",\"NameMatchMethodPointcut 通过匹配方法名进行匹配。\",\"AnnotationMatchingPointcut 通过匹对是否存在指定类型的注解进行匹配\",\"MethodMatcher分为静态匹配和动态匹配，以上属于静态匹配，目标方法第一次执行以后都不需要再次做匹配，会有缓存；动态匹配主是参数的匹配，每次执行都需要做匹配操作\"]},\"10\":{\"h\":\"Advice\",\"t\":[\"AOP通知在Spring中的对象\",\"像MethodBeforeAdvice、AfterReturningAdvice、AspectJAfterAdvice、ThrowsAdvice、AspectJAroundAdvice\",\"一般的Advice，在Aop代理对象执行方法时，都会通过适配器模式转换为对应的MethodInterceptor类\",\"而Around的类型直接实现的MethodInterceptor类\"]},\"11\":{\"h\":\"Advisor\",\"t\":[\"AOP切面在Spring中的对象\",\"通知器，定义在哪个Pointcut上执行哪个Advice\",\"public class DefaultPointcutAdvisor extends AbstractGenericPointcutAdvisor implements Serializable { private Pointcut pointcut = Pointcut.TRUE; /** * Create an empty DefaultPointcutAdvisor. * <p>Advice must be set before using setter methods. * Pointcut will normally be set also, but defaults to {@code Pointcut.TRUE}. */ public DefaultPointcutAdvisor() { } /** * Create a DefaultPointcutAdvisor that matches all methods. * <p>{@code Pointcut.TRUE} will be used as Pointcut. * @param advice the Advice to use */ public DefaultPointcutAdvisor(Advice advice) { this(Pointcut.TRUE, advice); } /** * Create a DefaultPointcutAdvisor, specifying Pointcut and Advice. * @param pointcut the Pointcut targeting the Advice * @param advice the Advice to run when Pointcut matches */ public DefaultPointcutAdvisor(Pointcut pointcut, Advice advice) { this.pointcut = pointcut; setAdvice(advice); } /** * Specify the pointcut targeting the advice. * <p>Default is {@code Pointcut.TRUE}. * @see #setAdvice */ public void setPointcut(@Nullable Pointcut pointcut) { this.pointcut = (pointcut != null ? pointcut : Pointcut.TRUE); } @Override public Pointcut getPointcut() { return this.pointcut; } @Override public String toString() { return getClass().getName() + \\\": pointcut [\\\" + getPointcut() + \\\"]; advice [\\\" + getAdvice() + \\\"]\\\"; } } \"]},\"12\":{\"h\":\"织入器\",\"t\":[\"Advisor类有了，那如何将切面织入目标对象生成对应的代理对象呢\",\"Spring提供了org.springframework.aop.framework.ProxyFactory类\",\"该类的主要方法\",\"通过构造器可以传入目标对象\",\"getProxy()获取最终的AOP代理对象\",\"看看getProxy()做了什么：\",\"通过其父类org.springframework.aop.framework.ProxyCreatorSupport的createAopProxy()方法获取AopProxy接口类的实现类，再通过AopProxy的getProxy()方法获取目标的Aop代理类。\",\"AopProxy的实现类有\",\"所以说SpringAOP通过Cglib和Jdk两种动态代理方式实现\",\"通过探寻createAopProxy()方法可以发现最终调用org.springframework.aop.framework.DefaultAopProxyFactory的createAopProxy()方法\",\"可以看到不同情况会使用不同的动态代理方法\",\"获取到对应的AopProxy后，调用getProxy()方法获取代理对象，这里拿JdkDynamicAopProxy类的展示\",\"Proxy.newProxyInstance(),JDK动态代理创建\",\"从ProxyFactory的方法中似乎没有将Advisor织入的方法，其实是其父类的父类org.springframework.aop.framework.AdvisedSupport提供的\",\"并且JdkDynamicAopProxy和CglibAopProxy也会持有AdvisedSupport类属性，用于获取Advisor、Advice等内容\"]},\"13\":{\"h\":\"AOP代理执行过程\",\"t\":[\"通过上述内容，明白AOP的代理生成是由Jdk或Cglib代理实现，那AOP代理对象执行方法时，又是如何根据切面来增强原方法的呢？\"]},\"14\":{\"h\":\"JdkDynamicAopProxy的invoke()\",\"t\":[\"大家都知道，Jdk动态代理中，代理增强的方法是由\",\"Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)方法中的第三个参数InvocationHandler的invoke方法实现的\",\"上一节中，JdkDynamicAopProxy使用Jdk动态代理实现Aop代理时，将this作为第三个参数传入，JdkDynamicAopProxy也确实实现了InvocationHandler接口\",\"因此AOP代理对各通知的调用在JdkDynamicAopProxy的invoke()方法中实现，方法中的关键部分\"]},\"15\":{\"h\":\"获取拦截器链\",\"t\":[\"使用持有的AdvisedSupport，获取目标方法的拦截器链\",\"拦截器链是通过AdvisedSupport中持有的Advisors，获取Pointcut进行方法的匹配，使用适配器模式生成MethodInterceptor(如果是动态匹配，会将MethodInterceptor和MethodMatcher封装为InterceptorAndDynamicMethodMatcher对象)，最后组成的集合\",\"由AdvisedSupport持有的advisorChainFactory属性(org.springframework.aop.framework.DefaultAdvisorChainFactory)调用getInterceptorsAndDynamicInterceptionAdvice()方法完成：\",\"@Override public List<Object> getInterceptorsAndDynamicInterceptionAdvice( Advised config, Method method, @Nullable Class<?> targetClass) { // This is somewhat tricky... We have to process introductions first, // but we need to preserve order in the ultimate list. AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); // 从AdvisedSupport中获取所有Advisor通知器 Advisor[] advisors = config.getAdvisors(); List<Object> interceptorList = new ArrayList<>(advisors.length); Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass()); Boolean hasIntroductions = null; //遍历通知器，根据Advisor持有的Pointcut 进行方法匹配 for (Advisor advisor : advisors) { if (advisor instanceof PointcutAdvisor) { // Add it conditionally. PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor; if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) { MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); boolean match; //方法匹配 if (mm instanceof IntroductionAwareMethodMatcher) { if (hasIntroductions == null) { hasIntroductions = hasMatchingIntroductions(advisors, actualClass); } match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions); } else { match = mm.matches(method, actualClass); } if (match) { //匹配成功，通过适配器将advisor中的Advice转换为MethodInterceptor MethodInterceptor[] interceptors = registry.getInterceptors(advisor); //根据是否是运行时匹配，如果是，则创建一个InterceptorAndDynamicMethodMatcher对象 //运行时匹配主要指，需要通过参数匹配的情况 if (mm.isRuntime()) { // Creating a new object instance in the getInterceptors() method // isn't a problem as we normally cache created chains. for (MethodInterceptor interceptor : interceptors) { interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); } } else { interceptorList.addAll(Arrays.asList(interceptors)); } } } } else if (advisor instanceof IntroductionAdvisor) { IntroductionAdvisor ia = (IntroductionAdvisor) advisor; if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } else { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } return interceptorList; } \"]},\"16\":{\"h\":\"拦截器链调用\",\"t\":[\"如果目标方法存在通知，就能获取相应的拦截器链，拦截器链的调用由ReflectiveMethodInvocation的proceed()执行\",\"ReflectiveMethodInvocation 通过构造器持有代理对象，目标对象，方法对象，方法参数，和拦截器集合\",\"protected ReflectiveMethodInvocation( Object proxy, @Nullable Object target, Method method, @Nullable Object[] arguments, @Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) { this.proxy = proxy; this.target = target; this.targetClass = targetClass; this.method = BridgeMethodResolver.findBridgedMethod(method); this.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments); this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers; } \",\"通过递归调用proceed()，遍历调用拦截器链，看一下proceed()方法\",\"最后都是调用拦截器的invoke方法，参数传入ReflectiveMethodInvocation对象自身，在拦截器中再调用proceed()来进行拦截器链的遍历调用\",\"public Object proceed() throws Throwable { // We start with an index of -1 and increment early. if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) { //当拦截器链全部调用完毕，调用目标方法，内部也是使用 AopUtils.invokeJoinpointUsingReflection()完成 return invokeJoinpoint(); } //获取下一个拦截器 Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); //判断是否为动态匹配 if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) { // 是动态匹配 // Evaluate dynamic method matcher here: static part will already have // been evaluated and found to match. InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice; Class<?> targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) { return dm.interceptor.invoke(this); } else { // Dynamic matching failed. // Skip this interceptor and invoke the next in the chain. return proceed(); } } else { // 不是动态匹配，直接调用各拦截器的invoke方法 // It's an interceptor, so we just invoke it: The pointcut will have // been evaluated statically before this object was constructed. return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); } } \",\"以下AOP切面示例\",\"@Aspect @Component public class A { @Before(\\\"execution(public void com.example.springbootaopdemo.demo.Cat.eat())\\\") public void before() { System.out.println(\\\"before\\\"); } @Around(\\\"execution(public void com.example.springbootaopdemo.demo.Cat.eat())\\\") public void around(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\\\"around-before\\\"); joinPoint.proceed(); System.out.println(\\\"around-after\\\"); } @After(\\\"execution(public void com.example.springbootaopdemo.demo.Cat.eat())\\\") public void after() { System.out.println(\\\"after\\\"); } } public interface Animal { void eat(); } @Component(\\\"cat\\\") public class Cat implements Animal{ @Override public void eat(){ System.out.println(\\\"猫吃鱼\\\"); } } \",\"在ReflectiveMethodInvocation的proceed()执行时，拦截链中的各拦截器\",\"MethodBeforeAdviceInterceptor的invoke()\",\"public Object invoke(MethodInvocation mi) throws Throwable { //先调用before类型的advice，再调用mi.proceed()继续调用后续拦截器 //before 内部使用AbstractAspectJAdvice的模板方法invokeAdviceMethod this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis()); return mi.proceed(); } \",\"AspectJAfterAdvice的inovke()\",\"public Object invoke(MethodInvocation mi) throws Throwable { //先继续调用后续拦截器为了最后执行原方法，再执行after方法 //因为After是无论原方法执行成功与否都需要执行的逻辑，所以使用finally try { return mi.proceed(); } finally { //执行父类AbstractAspectJAdvice的模板方法，来执行after方法 invokeAdviceMethod(getJoinPointMatch(), null, null); } } \",\"AspectJAroundAdvice的invoke()方法\",\"public Object invoke(MethodInvocation mi) throws Throwable { if (!(mi instanceof ProxyMethodInvocation)) { throw new IllegalStateException(\\\"MethodInvocation is not a Spring ProxyMethodInvocation: \\\" + mi); } ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi; ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi); JoinPointMatch jpm = getJoinPointMatch(pmi); //调用AbstractAspectJAdvice的invokeAdviceMethod方法 return invokeAdviceMethod(pjp, jpm, null, null); } \",\"没有显示的调用proceed()，因为对于Around类似的通知，proceed()由ProceedingJoinPoint调用，调用时机交给用户控制\",\"对于用户来说调用proceed()是调用目标原方法，内部其实先去调用剩余的拦截器链才最后调用的目标原方法。\",\"如上述A切面的Around方法\",\"@Around(\\\"execution(public void com.example.springbootaopdemo.demo.Cat.eat())\\\") public void around(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\\\"around-before\\\"); joinPoint.proceed(); System.out.println(\\\"around-after\\\"); } \",\"根据上述例子拦截器链的顺序，执行过程顺序为\"]},\"17\":{\"h\":\"通知类的排序\"},\"18\":{\"h\":\"第一次排序\",\"t\":[\"上一章节看到，Cat类的AOP代理对象在执行相关方法时，通知类构造的拦截器顺序是Around->Before->After，而我们在切面中定义Advice时先按顺序是Before->Around->After，所以Aspect切面中的Advice类生成后，肯定进行了排序。\",\"首先得弄清楚Advice类在何时创建\",\"经过调用栈发现在切面类Bean的AnnotationAwareAspectJAutoProxyCreator后置处理器的postProcessBeforeInstantiation()方法中(实质调用的是AbstractAutoProxyCreator的方法)，最终会调用BeanFactoryAspectJAdvisorsBuilder的buildAspectJAdvisors()来生成和缓存当前Aspect中的Advisor\",\"这里生成的Advisor是InstantiationModelAwarePointcutAdvisorImpl类，创建InstantiationModelAwarePointcutAdvisorImpl对象时，在构造器中也创建了Advice\",\"InstantiationModelAwarePointcutAdvisorImpl类在为目标对象创建代理对象时，会转换为Advisor类型\",\"getAdvisors()方法调用的是ReflectiveAspectJAdvisorFactory类实现的方法\",\"debug会发现其中的getAdvisorMethods(aspectClass)语句给出的Method集合就是按照Around->Before->After顺序给出的\",\"看一下getAdvisorMethods()方法，主要到执行了methods.sort(adviceMethodComparator)\",\"adviceMethodComparator是一个Comparator，内容在该类静态代码块中复制\",\"所以一个切面内的Advice顺序按照Around, Before, After, AfterReturning, AfterThrowing\"]},\"19\":{\"h\":\"第二次排序\",\"t\":[\"当目标对象在后置处理器中进行AOP代理创建时，会查询所有属于目标对象的通知器类，那不同切面的Advisor如何排序\",\"找到目标对象的AOP代理对象生成的后置处理方法AbstractAutoProxyCreator的postProcessAfterInitialization()其中的wrapIfNecessary()\",\"其中的getAdvicesAndAdvisorsForBean()就是查找目标对象是否有Advisor\",\"进入方法，在其子类AbstractAdvisorAutoProxyCreator的findEligibleAdvisors()方法中可以看到eligibleAdvisors = sortAdvisors(eligibleAdvisors);\",\"使用的是子类AspectJAwareAdvisorAutoProxyCreator的sortAdvisors()\",\"protected List<Advisor> sortAdvisors(List<Advisor> advisors) { List<PartiallyComparableAdvisorHolder> partiallyComparableAdvisors = new ArrayList<>(advisors.size()); for (Advisor advisor : advisors) { //构造PartiallyComparableAdvisorHolder 实现了PartialComparable // DEFAULT_PRECEDENCE_COMPARATOR 赋值为 AspectJPrecedenceComparator类对象，该对象拥有一个AnnotationAwareOrderComparator(OrderComparator的子类) partiallyComparableAdvisors.add( new PartiallyComparableAdvisorHolder(advisor, DEFAULT_PRECEDENCE_COMPARATOR)); } //进行偏序排序 List<PartiallyComparableAdvisorHolder> sorted = PartialOrder.sort(partiallyComparableAdvisors); if (sorted != null) { List<Advisor> result = new ArrayList<>(advisors.size()); for (PartiallyComparableAdvisorHolder pcAdvisor : sorted) { result.add(pcAdvisor.getAdvisor()); } return result; } else { //偏序排序的结构为空时，使用父类的sortAdvisors，内部就是AnnotationAwareOrderComparator.sort(advisors) return super.sortAdvisors(advisors); } } \",\"偏序排序没有深入研究，但是在PartialOrder.sort()方中还是调用了DEFAULT_PRECEDENCE_COMPARATOR(AspectJPrecedenceComparator)的compareTo方法，AspectJPrecedenceComparator类的compareTo实际使用的AnnotationAwareOrderComparator的compareTo，AnnotationAwareOrderComparator并没重写compareTo，使用的OrderComparator的方法，也就是按照Advisor的Order进行排序的\",\"那Advisor的Order哪来的。\",\"在第一次排序中我们说到Advisor在切面Bean初始化时创建，并且创建的实际上是InstantiationModelAwarePointcutAdvisorImpl类，其是间接实现了Ordered接口的\",\"InstantiationModelAwarePointcutAdvisorImpl的getOrder()方法最终是调用BeanFactoryAspectInstanceFactory的getOrder()\",\"其中的name就是切面类bean的name\",\"@Override public int getOrder() { Class<?> type = this.beanFactory.getType(this.name); if (type != null) { if (Ordered.class.isAssignableFrom(type) && this.beanFactory.isSingleton(this.name)) { return ((Ordered) this.beanFactory.getBean(this.name)).getOrder(); } return OrderUtils.getOrder(type, Ordered.LOWEST_PRECEDENCE); } return Ordered.LOWEST_PRECEDENCE; } \",\"也就是最终一个AOP代理对象中的拦截器或者说通知器的顺序，是按照切面类的Order来的，如果是同一个切面类中的是按照既定的Around, Before, After, AfterReturning, AfterThrowing顺序\"]},\"20\":{\"h\":\"Spring声明式事务\"},\"21\":{\"h\":\"五种失效情况\",\"t\":[\"类没有被 Spring 管理\",\"方法不是public修饰\",\"异常被捕获（事务默认只在抛出运行时异常）\",\"同一个类中，方法内部调用\",\"方法内部使用this.xxx()的方式调用事务存在事务的方法； 失效的本质是，this指的的是对象本身，而不是代理对象，事务是由AOP代理来实现的，处理事务的增强方法都是在代理对象的方法中，因此使用this对象本身调用方法AOP会失效。 为什么this指的是对象本身而不是代理对象呢，原因，代理对象执行方法时，增强方法在代理对象的方法中，而原对象方法还是使用原对象来调用的，由原对象调用的方法中使用this，指向的当然时原对象。 解决，不用this调用本类中的方法，从容器中获取bean再调用\",\"MySQL存储引警不支持事务\",\"参考：https://blog.csdn.net/qq_52423918/article/details/130806813\"]},\"22\":{\"h\":\"传播行为\",\"t\":[\"事务协调员（内部方法）对事务管理员（外部方法）是否携带事务而进行的处理态度\",\"1.REQUIRED\",\"当外部方法存在事务时，内部方法事务将加入外部事务，内部事务产生回滚时，外部事务也回滚 当外部方法不存在事务时，内部方法事务就创建自己的事务\",\"2.REQUIRES_NEW\",\"当外部方法存在事务时，内部方法创建自己独立的事务，不受外部事务影响 当外部方法不存在事务时，内部方法创建自己独立的事务\",\"3.NESTED\",\"当外部方法存在事务时，内部方法事务成为外部事务的嵌套子事务，当内部事务回滚时只会回滚到内部事务执行前状态 当外部方法不存在事务时，内部方法创建自己独立的事务执行\",\"4.MANDATORY\",\"当外部方法存在事务，内部方法事务加入\",\"当外部方法不存在事务时，抛出异常\",\"5.SUPPORTS\",\"当外部方法存在事务，内部方法事务加入 当外部方法不存在事务时，内部方法就不使用事务\",\"6.NOT_SUPPORTED\",\"不管外部方法是否有事务，内部方法的事务都不生效，执行到内部方法时，外部事务挂起等待内部方法执行\",\"7.NEVER\",\"总是非事务地执行，如果外部方法存在事务，则抛出异常。\"]},\"23\":{\"h\":\"Spring事务源码分析\",\"t\":[\"spring使用AOP实现声明式事务，其中涉及到许多配置和属性读取，如事务管理器、事务传播行为等待；\",\"源码分析之前，需要明确Spring事务帮我们做了什么：\",\"从数据池中获取数据库连接\",\"开启事务并设置手动提交\",\"调用原方法\",\"提交/回滚 事务\",\"此处暂时研究spring事务的创建、提交、回滚相关执行流程\",\"案例\",\"public class A { @Transactional public void a() { Dept dept = new Dept(); dept.setDeptName(\\\"测试事务3\\\"); deptService.save(dept); B b = new B(); b.b(); } } public class B { @Transactional public void b() { User user = new User(); user.setUserName(\\\"测试事务\\\"); user.setNickName(\\\"测试事务\\\"); user.setPassword(\\\"测试事务\\\"); userService.save(user); } } \",\"👇当执行 a()方法时，AOP代理中会调用TransactionInterceptor类中的invoke方法，核心在其父类的invokeWithinTransaction方法中，包含了整个事务处理的过程\",\"👇来看一下事务开启做了什么，createTransactionIfNecessary\",\"开启事务的具体处理由事务管理器的抽象类(AbstractPlatformTransactionManager)定义，使用getTransaction模板方法，传入事务属性\",\"doGetTransaction 返回一个事务对象 由具体的事务管理器实现类实现 一般为DataSourceTransactionManager\",\"从事务同步管理器中获取数据库连接资源，该资源是通过ThreadLocal与线程绑定的，TransactionSynchronizationManager保存着当前线程事务中的事务资源和一些事务信息(如当前事务的名称、事务隔离级别等)，第一次执行时，TransactionSynchronizationManager中并不存在资源，ConnectionHolder为null\",\"创建一个事务对象存放当前事务的数据连接持有对象 和 是否为新持有对象的标识，后续通过该数据持有对象获取连接。\",\"回到getTransaction继续执行，isExistingTransaction判断当前是否已存在事务，分支内是对于子事务如何处理的入口\",\"DataSourceTransactionManager 的 isExistingTransaction\",\"通过查看事务对象是否存在数据连接持有对象 数据连接是否存在活动事务标志，来判断是否已存在事务；声明式事务方法第一次执行时，条件显然不成立；\",\"继续执行\",\"通过对事务属性中的事务传播行为判断，三个常用的传播行为，调用startTransaction 开启事务\",\"该方法会创建一个事务状态对象，保存着当前事务的属性，事务对象，是否为新事物等等信息，用于后续事务处理的；\",\"继续执行到 的 doBegin，由事务管理器实现类实现\",\"此处是DataSourceTransactionManager的实现\",\"会从数据池中获取连接，并将连接持有对象存入到事务对象中，设置新持有对象状态为true，然后将连接设为事务手动提交；连接持有对象活动事务标志设上，保证前面判断已存在事务的正确性；由于是新持有对象，可执行TransactionSynchronizationManager的绑定操作，这就保证了，子事务在开启的过程中doGetTransaction()方法中能够获取同一持有对象。\",\"回到startTransaction，继续执行prepareSynchronization方法，将当前事务的状态(如：当前事务开启状态、激活状态、隔离级别)、初始化事务同步回调内容，存放的是当前需要操作的事务信息。\",\"至此开启事务结束，返回事务状态对象，回到invokeWithinTransaction执行带代理的原方法\",\"如果当前方法中没有调用其他存在事务的方法，那么原方法调用完成后，直接回滚或者提交\",\"先看看提交\",\"提交由事务管理器抽象类提供模板方法，其中triggerBeforeCommit(status)和triggerBeforeCompletion(status);方法是通过获取TransactionSynchronizationManager中配置的事务提交前执行方法，进行事务提交前的前置操作，用户可以根据情况在TransactionSynchronizationManager中注册事务前置和后置方法。\",\"事务管理器的提交方法其实就是获取存储的事务连接对象，手动commit。\",\"可以看到，提交一定要是事务状态为新事务时，才能提交；\",\"回到案例，当原方法执行时，又执行了一个声明式事务方法b.b();\",\"此时重新开始执行上面分析的事务开启方法，在isExistingTransaction处，因为第一个事务开启时将连接持有对象与线程绑定由TransactionSynchronizationManager管理，此处判断为true,执行另一创建事务状态对象的逻辑handleExistingTransaction\",\"可以看到，当判断已存在事务时，会根据事务传播行为，来执行不同的逻辑，案例的子事务传播行为是默认的PROPAGATION_REQUIRED走最后一个创建事务状态过程，可以看到newTransaction，设置为了false\",\"所以当子事务方法，执行到提交操作时，并不会走提交，父事务执行提交时才会真正提交。\",\"来看看回滚\",\"原方法抛出异常时，进入处理（当原方法捕获了异常但是不抛出新异常，就会事务失效）\",\"会判断当前异常是否是定义的异常，如果注解没有定义回滚异常，就使用父类方法匹对(匹对异常RuntimeException或者Error)\",\"匹对失败直接执行提交的操作，匹对成功执行回滚操作（此处就是为什么方法中抛出的异常与定义的回滚异常不一致时，事务失效的原因）\",\"回滚中，对事务状态做了许多判断，在案例的情况下，子事务加入父事务没有开启新事物，status.isNewTransaction()为false,就进入分支执行doSetRollbackOnly，为事务的连接持有对象设置了一个回滚标记\",\"所以如果加入父事务的子事务抛出了异常，此时不管父事务的原方法是捕获了异常，还是正常抛出，事务都会回滚\",\"如果父事务真正抛出异常，那事务状态中isNewTransaction为true，直接回滚\",\"如果父事务将子事务的异常捕获且没有抛出新异常，那父事务其实会正常进入提交的操作但是最后还是会回滚，那为什么异常被捕获事务没有失效，我们回看提交模板方法中\",\"在processCommit前其实还有判断\",\"defStatus.isGlobalRollbackOnly() 其实就是判断，当前连接持有对象中的回滚标记是否为true，子事务中将其置为true，因此，最后还是进行了回滚\"]},\"24\":{\"h\":\"多线程下事务的处理\",\"t\":[\"通过源码分析，spring处理事务的方式本质就是帮我们获取数据库连接，调用数据库连接的手动提交和回滚；而获取的数据库连接资源绑定在线程中由TransactionSynchronizationManager帮忙管理，事务其实就是同一连接中的数据库操作的一致性；多线程下spring声明式事务的失效原因是线程之间的数据隔离，也就是多线程下获取的数据库连接都不一致了，就谈不上事务了。\",\"我们使用Mybatis时，mybatis在执行sql前会从TransactionSynchronizationManager中取获取数据库连接\",\"所以可以在子线程调用开启事务的方法之前，将主线程中获取到的数据库连接资源绑定到子线程上，并将子线程的异常正常抛出，保证正常回滚\",\"例：\",\"@Transactional public void test() { ConnectionHolder resource = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource); System.out.println(Thread.currentThread()); System.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); //子线程1 CompletableFuture<Boolean> future1 = CompletableFuture.supplyAsync(() -> { System.out.println(Thread.currentThread()); TransactionSynchronizationManager.bindResource(dataSource, resource); Dept dept = new Dept(); dept.setDeptName(\\\"测试事务\\\"); return deptService.save(dept); }).whenComplete((result, ex) -> { TransactionSynchronizationManager.unbindResource(dataSource); }); //子线程2 CompletableFuture<Boolean> future2 = CompletableFuture.supplyAsync(() -> { System.out.println(Thread.currentThread()); TransactionSynchronizationManager.bindResource(dataSource, resource); mutiplyThreadTranscationManager.test();//开启默认事务传播行为 return true; }).whenComplete((result, ex) -> { TransactionSynchronizationManager.unbindResource(dataSource); }); CompletableFuture.allOf(future1, future2).join(); List<Supplier> tasks = new ArrayList<>(); Dept dept1 = new Dept(); dept1.setDeptName(\\\"测试事务3\\\"); deptService.save(dept1); int a = 1 / 0; } //MutiplyThreadTranscationManager @Transactional public void test(){ User user = new User(); user.setUserName(\\\"测试事务\\\"); user.setNickName(\\\"测试事务\\\"); user.setPassword(\\\"测试事务\\\"); userService.save(user); } \"]},\"25\":{\"h\":\"循环依赖\",\"t\":[\"类A依赖类B，类B也依赖类A，这种情况就会出现循环依赖。 Bean A → Bean B → Bean A\",\"循环依赖会导致内存溢出\",\"public class AService { private BService bService = new BService(); } public class BService { private AService aService = new AService(); } \",\"当通过 new AService() 创建一个对象时你会获得一个栈溢出的错误 因为调用 new AService() 时会先去执行属性 bService 的初始化, 而 bService 的初始化又会去执行AService 的初始化， 这样就形成了一个循环调用，最终导致调用栈内存溢出。\",\"注意：从springboot2.6.0开始，默认关闭循环依赖，如果需要开启，添加配置spring.main.allow-circular-references=true\"]},\"26\":{\"h\":\"解决循环依赖的简单思路\",\"t\":[\"// 模拟spring解决循环依赖的缓存 key存类名 value存bean实例，防止循环依赖后不断创建新对象导致栈内存溢出 private static Map<String, Object> cacheMap = new HashMap<>(); public static void main(String[] args) throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException { Class[] classes = {Dept.class, Stuff.class}; for (Class classA : classes) { //获取bean getBean(classA); } System.out.println(getBean(Stuff.class).getDept() == getBean(Dept.class)); System.out.println(getBean(Dept.class).getStuff() == getBean(Stuff.class)); } public static <T> T getBean(Class<T> bean) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { // 获取要创建的bean的类名 String beanName = bean.getSimpleName().toLowerCase(); // 判断缓存map的key里面是否有该类名 if (cacheMap.containsKey(beanName)) { //存在直接返回实例bean return (T) cacheMap.get(beanName); } //不存在类名，使用反射得到实例化的bean obj Object obj = bean.getDeclaredConstructor().newInstance(); //将实例化的bean和类名存入缓存map中 cacheMap.put(beanName, obj); //获取bean里面的属性 Field[] fields = obj.getClass().getDeclaredFields(); //设置的是bean里面的属性 for (Field field : fields) { field.setAccessible(true); Class<?> fieldType = field.getType(); //属性的类名 String fieldName = fieldType.getSimpleName().toLowerCase(); // 第一参数是表示【这个field是属于哪个对象的】，第二个参数放set的值 //这里第二个查询在缓存map里查找是否有该属性类名的bean，存在直接取出来set进去，不存在递归调用getBean()创建该类的bean field.set(obj, cacheMap.containsKey(fieldName)?cacheMap.get(fieldName): getBean(fieldType)); } //最后返回bean return (T) obj; } \"]},\"27\":{\"h\":\"spring是如何解决循环依赖的\",\"t\":[\"众所周知，spring使用三级缓存解决循环依赖问题\",\"singletonObjects：用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用\",\"earlySingletonObjects：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），如果存在循环依赖 会通过第三级缓存生成早期引用存放在此。\",\"singletonFactories：存放单例对象工厂对象，用于生成早期引用。\",\"获取缓存bean的实现在DefaultSingletonBeanRegistry类的方法getSingleton()中\",\"protected Object getSingleton(String beanName, boolean allowEarlyReference) { // Quick check for existing instance without full singleton lock //先从第一个Map中获取成品Bean Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) { //第一个Map中没有，从第二个Map中获取半成品Map singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null && allowEarlyReference) { //如果半成品也没有，那就需要从第三个Map中获取工厂对象来获取半成品Bean //加锁保证单例性 synchronized (this.singletonObjects) { // Consistent creation of early reference within full singleton lock singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null) { ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { //获取工厂对象，调用工厂对象的getObject方法，其中会判断该bean是否需要创建AOP singletonObject = singletonFactory.getObject(); //创建好的对象，放进第二个Map this.earlySingletonObjects.put(beanName, singletonObject); //从第三个Map中删除对应工厂对象，保证单例性 this.singletonFactories.remove(beanName); } } } } } } return singletonObject; } \",\"该方法还有个重载方法，在本文中将上面的getSingleton()称为getSingleton1()，将下面的方法称为getSingleton2()\",\"public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) { Assert.notNull(beanName, \\\"Bean name must not be null\\\"); synchronized (this.singletonObjects) { Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { if (this.singletonsCurrentlyInDestruction) { throw new BeanCreationNotAllowedException(beanName,\\\"Singleton bean creation not allowed while singletons of this factory are in destruction \\\" +\\\"(Do not request a bean from a BeanFactory in a destroy method implementation!)\\\"); } if (logger.isDebugEnabled()) { logger.debug(\\\"Creating shared instance of singleton bean '\\\" + beanName + \\\"'\\\"); } beforeSingletonCreation(beanName); boolean newSingleton = false; boolean recordSuppressedExceptions = (this.suppressedExceptions == null); if (recordSuppressedExceptions) { this.suppressedExceptions = new LinkedHashSet<>(); } try { singletonObject = singletonFactory.getObject(); newSingleton = true; } catch (IllegalStateException ex) { // Has the singleton object implicitly appeared in the meantime -> // if yes, proceed with it since the exception indicates that state. singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { throw ex; } } catch (BeanCreationException ex) { if (recordSuppressedExceptions) { for (Exception suppressedException : this.suppressedExceptions) { ex.addRelatedCause(suppressedException); } } throw ex; } finally { if (recordSuppressedExceptions) { this.suppressedExceptions = null; } afterSingletonCreation(beanName); } if (newSingleton) { addSingleton(beanName, singletonObject); } } return singletonObject; } } \"]},\"28\":{\"h\":\"doGetBean()\",\"t\":[\"假设A与B循环依赖，从注册A的bean开始；\",\"AbstractBeanFactory的getBean()为入口，调用doGetBean()\",\"doGetBean一开始就使用getSingleton()，追进去查看，发现使用的是getSingleton1()\",\"第二个参数为true，即如果第二层缓存不存在，会查看第三层缓存；\",\"此时A是初次创建，三层缓存中并不存在任何相关对象，返回null\",\"不进入该判断分支，进入else\",\"其中的dependsOn依赖处理，并不是指属性依赖注入的依赖初始化\",\"而是处理使用xml定义bean时定义的depends-on，或者@DependsOn注解的依赖；\",\"dependsOn可以指定bean的创建和销毁顺序，所以需要先保证dependsOn依赖的bean先初始化；此处产生的循环依赖无法解决，会抛出异常；\",\"我们来看一下创建bean部分，使用了getSingleton2(),lambda传入第二个工厂的getObject()实现方法\",\"具体查看一下，执行了哪些操作\",\"这个创建前校验，往singletonsCurrentlyInCreation中添加了当前beanName，此处也是循环依赖检测的一个关键点。\",\"接下去执行lambda内容createBean()，根据BeanDefinition执行实例化前处理器的相关处理，然后进入doCreateBean()\"]},\"29\":{\"h\":\"doCreateBean()\",\"t\":[\"AbstractAutowireCapableBeanFactory类中的doCreateBean方法，创建bean的具体实现。\",\"该方法主要三大部分：\",\"Bean的实例化\",\"Bean属性填充\",\"Bean的初始化\",\"实例化\",\"// Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { instanceWrapper = createBeanInstance(beanName, mbd, args); } Object bean = instanceWrapper.getWrappedInstance(); Class<?> beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } \",\"实例化没有深入研究，最终创建了一个Bean的原始对象，还没有对其中的属性进行填充\",\"实例化后处理循环依赖的关键点：如果当前bean为单例，处于创建中，并且开启了循环依赖的配置，那么earlySingletonExposure为true，就调用addSingletonFactory，将工厂对象存进第三级缓存\",\"springboot 2.6.0后加入的循环依赖的配置，默认关闭，配置在此处影响了三级缓存\",\"getEarlyBeanReference()：生成二级缓存中早期引用的方法，如果bean存在实现了SmartInstantiationAwareBeanPostProcessor类的后置处理器，就通过后置处理器的getEarlyBeanReference()方法得到代理后的引用，不然就返回原始引用。(这就是@Async的循环依赖无法解决的关键)；\",\"this.earlyProxyReferences.put(cacheKey, bean);该语句使得初始化时相同后置处理器不会再次生成产生代理对象。\",\"// Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isTraceEnabled()) { logger.trace(\\\"Eagerly caching bean '\\\" + beanName + \\\"' to allow for resolving potential circular references\\\"); } //往第三个Map中存入beanName对应的一个ObjectFactory，该工厂对象通过lambda传入一个方法 //该方法就是用于在循环依赖发生后，创建AOP或者返回原始对象的方法 addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); } //Obtain a reference for early access to the specified bean, typically for the purpose of resolving a circular reference. protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) { Object exposedObject = bean; if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) { for (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) { exposedObject = } } return exposedObject; } //主要实现方法 @Override public Object getEarlyBeanReference(Object bean, String beanName) { Object cacheKey = getCacheKey(bean.getClass(), beanName); this.earlyProxyReferences.put(cacheKey, bean); return wrapIfNecessary(bean, beanName, cacheKey); } \",\"属性填充\",\"依赖注入就在这完成，如果循环依赖没有开启，该方法就会异常\",\"populateBean(beanName, mbd, instanceWrapper);\",\"根据调试查看调用链\",\"applyPropertyValues() -> resolveValueIfNecessary() -> resolveReference() -> getBean()\",\"获取bean的需要注入的属性，最终又是调用getBean()去获取需要属性注入的B对象\",\"初次获取B对象，和上面流程一样，又进入属性填充，发现需要注入A对象，又调用getBean()获取A对象，循环就开始，来看一下第二次获取A有什么不同\",\"根据getSingleton1()此时能够从三级缓存中获取工厂对象，从而获取早期引用对象，就进入if分组，最后注入B对象中属性中，B对象注入A对象属性中\",\"如果没有打开循环依赖配置，此处依旧获取null，和初次创建A对象一样就会走else分支，执行getSingleton2()，再执行其中的beforeSingletonCreation()方法时，应为singletonsCurrentlyInCreation集合已经存在A对象的beanName而添加失败，抛出异常。\",\"初始化\",\"属性填充成功后，会进行初始化，在AbstractAutowireCapableBeanFactory类中的initializeBean(String beanName, Object bean,RootBeanDefinition mbd)方法中\",\"进行bean的后置处理器处理，如代理对象的创建\",\"但是此处不会生成获取早期引用方法(getEarlyBeanReference())得到的代理对象，因为相关后置处理器的后置处理方法中，会去获取缓存中是否已经有记录，this.earlyProxyReferences.remove(cacheKey)，不存在时才会创建代理对象，不然返回原始对象。\",\"校验\",\"初始化后，如果允许早期暴露单例(earlySingletonExposure为true)，并且能够从一二级缓存中获取早期引用(getSingleton(beanName, false)第二参数为false，只会从第二)，会比较初始化后的对象和原始对象引用是否一致，如果一致，最终使用三级缓存中获得的引用，保证了循环依赖中注入的引用和bean创建好后的引用一致；\"]},\"30\":{\"h\":\"为什么一级缓存不行\",\"t\":[\"假设只有的第一层Map，存放刚实例化后的Bean，引用不变的情况下，能给解决简单对象的循环依赖问题；\",\"为什么不使用一级缓存\",\"Spring Bean的创建过程主要分为三部分：\",\"创建实例 createBeanInstance\",\"填充依赖属性 populateBean\",\"初始化bean initializeBean\",\"如果只有一级缓存，什么阶段存放，放在初始化后就无法解决循环依赖；放在实例化后无法解决代理对象的循环依赖问题\",\"所以在Spring框架下，想使用一级缓存解决循环依赖不合理，至少需要二级缓存\"]},\"31\":{\"h\":\"为什么二级缓存不够\",\"t\":[\"如果二级缓存直接存储ObjectFactory对象，用于提前暴露代理引用，那么如果A对象依赖B和C，而B和C又依赖A的情况下\",\"B、C中注入的A会是两个对象，因为B注入A时使用的二级缓存ObjectFactory对象创建A，C注入A时也是使用的二级缓存ObjectFactory对象创建A，创建的都是新对象；\",\"我的理解就是，第三个Map即解决存在AOP情况下的循环依赖问题，又保证第二个Map中存放的始终是半成品Bean，层次分；\"]},\"32\":{\"h\":\"spring无法解决的循环依赖\"},\"33\":{\"h\":\"构造器注入的循环依赖无法解决\",\"t\":[\"spring处理循环依赖都是在实例化之后，但是构造器的注入是发生在实例化期间，在此期间三个map中都不会存在可获取的Bean，无法应用spring的三层缓存\"]},\"34\":{\"h\":\"使用@Async\",\"t\":[\"参考：https://www.yisu.com/jc/724480.html\",\"因为使用@Async的类的代理对象生成和AOP代理对象生成使用的是不同的类的方法，\",\"一般的AOP动态代理是依靠 AnnotationAwareAspectJAutoProxyCreator 获取的\",\"而@Async的代理是通过AsyncAnnotationBeanPostProcessor 获取的\",\"我们知道在spring的第三层缓存中放着ObjectFactory对象，用于获取对象的早期引用，如果对象需要代理就可以通过getEarlyBeanReference方法获取\",\"但是getEarlyBeanReference方法中，只会通过SmartInstantiationAwareBeanPostProcessor类的实现类的后置处理器来获取代理对象，而AsyncAnnotationBeanPostProcessor并不没有实现SmartInstantiationAwareBeanPostProcessor，因此在此处@Async的类获取到的早期引用是原始对象，当进入到第三阶段初始化时才会通过AsyncAnnotationBeanPostProcessor获取代理对象，\",\"doCreateBean创建bean流程中，初始化后，会比较初始化后的对象与原始对象是否为同一引用\",\"而普通AOP代理在循环依赖的情况下，初始化阶段时不会获取代理对象的，因为在二级缓存中已经存在代理对象的引用，而使用@Async的代理对象是在初始化阶段得到的，那么exposedObject == bean就为fasle，随后进入检查当前bean是否依赖其他bean，存在依赖其他bean抛异常BeanCurrentlyInCreationException\"]},\"35\":{\"h\":\"SpringBoot\"},\"36\":{\"h\":\"SpringBoot的AOP代理生成流程\",\"t\":[\"主要通过AnnotationAwareAspectJAutoProxyCreator类后置处理器，在bean生命周期的初始化阶段，后置处理器处理时生成AOP代理\",\"@EnableAspectJAutoProxy注解中通过@Import导入AspectJAutoProxyRegistrar类\",\"在AspectJAutoProxyRegistrar类中注册AnnotationAwareAspectJAutoProxyCreator后置处理器\",\"在Bean的初始化阶段会根据各后置处理器进行处理，其中通过AnnotationAwareAspectJAutoProxyCreator 调用 postProcessBeforeInitialization()方法获取AOP代理对象\",\"AbstractAutowireCapableBeanFactory类中的方法：\",\"AnnotationAwareAspectJAutoProxyCreator 并没有实现postProcessBeforeInitialization()，实则调用的AbstractAutoProxyCreator类的方法\",\"wrapIfNecessary()方法中的createProxy()方法，就是使用ProxyFactory创建的AOP代理对象\"]},\"37\":{\"h\":\"SpringCloud\"},\"38\":{\"h\":\"SpringCloudGateway\"},\"39\":{\"h\":\"路由装配过程\",\"t\":[\"路由配置主要使用yml配置文件和编码两种形式，在实际使用中，这种静态方式的路由配置可能无法满足需求，需要实现动态路由；\",\"从路由装配的过程看看能否实现动态路由\",\"静态路由的配置对象RouteDefinition\",\"项目启动，加载GatewayAutoConfiguration时，注册一个PropertiesRouteDefinitionLocator类将网关配置文件信息加载到内存中\",\"PropertiesRouteDefinitionLocator是RouteDefinitionLocator的一个实现类;RouteDefinitionLocator接口定义了获取路由定义信息的方法\",\"RouteDefinitionLocator的实现类如下：\",\"CachingRouteDefinitionLocator 一个RouteDefinitionLocator包装类，将RouteDefinition缓存在ConcurrentHashMap中\",\"PropertiesRouteDefinitionLocator 如上所述，从配置文件中获取RouteDefinition\",\"DiscoveryClientRouteDefinitionLocator 从注册中心获取服务实例，构造RouteDefinition\",\"InMemoryRouteDefinitionRepository和RedisRouteDefinitionRepository 都是间接实现RouteDefinitionLocator，这两个类拥有save和delete方法，更新存放在自己属性中的路路由信息，是实现动态路由的关键之一\",\"CompositeRouteDefinitionLocator 也是一个RouteDefinitionLocator包装类，组合所有RouteDefinitionLocator，用其getRouteDefinitions方法统一提供RouteDefinition\",\"接下去看配置类的加载内容：\",\"InMemoryRouteDefinitionRepository使用了@ConditionalOnMissingBean注解，那我们可以通过直接注入RouteDefinitionRepository类的实例来实现对路由配置的增加和删除\",\"CompositeRouteDefinitionLocator 使用@Primary注解，在其他需要注入RouteDefinitionLocator类的地方，会优先使用改类，也就达到了统一提供getRouteDefinitions方法的目的\",\"来看一下InMemoryRouteDefinitionRepository类 可以做什么\",\"通过save和delete方法，维护保存在routes属性中的RouteDefinition信息\",\"save和delete方法来自RouteDefinitionWriter接口，由RouteDefinitionRepository继承\",\"现在如何对路由配置进行增加删除的入口已经找到，那如何实现动态，继续查找配置\",\"RouteDefinitionRouteLocatorRouteLocator的实现类之一\",\"从接口方法中可以知道，该类是用来生成Route，查看实现类\",\"来看一下具体做了啥\",\"获取了 路由定义定位器（RouteDefinitionLocator），过滤器工厂和断言工厂，用于生成Route；\",\"继续查看配置类：\",\"注册了CachingRouteLocator 一个RouteLocator的包装类，和RouteDefinitionLocator的处理类似，统一提供Routes，该类是实现动态更新的关键\",\"看一下具体内容：\",\"该类还是一个监听器，实现了ApplicationListener，监听RefreshRoutesEvent事件\",\"监听到事件后，会做何处理：\",\"监听到事件后，调用 fetch()或fetch(Map<String, Object> metadata)方法，方法内部使用RouteLocator重新获取Route，RouteLocator又是通过RouteDefinitionLocator获取RouteDefinition，也就是能从RouteDefinitionRepository的实现类中（InMemoryRouteDefinitionRepository、RedisRouteDefinitionRepository后者我们自定义的实现类）重新获取维护着的RouteDefinition信息\",\"重新获取到的Route，调用publishRefreshEvent方法，更新cache\",\"至此，使用该事件发布订阅机制就可以实现动态的更新CachingRouteLocator中的Route信息\",\"Gateway中通过RoutePredicateHandlerMapping类，在其中由属性RouteLocator获取Route的断言遍历匹配exchange，将route存入exchange，然后交给后续的FilteringWebHandler，匹配相应的过滤器执行相应内容；\",\"CachingRouteLocator 使用@Primary注解，所以RoutePredicateHandlerMapping拿到的就是CachingRouteLocator类，CachingRouteLocator是装配形成Route的最后一个环节，通过该类更新路由信息就可以实现动态路由\",\"使用该事件发布订阅机制实现动态更新路由的大致步骤：\",\"1、自定义实现RouteDefinitionRepository接口\",\"2、根据需求使用数据库、缓存等，实现getRouteDefinitions、save、delete方法\",\"3、更新操作完成后，发布一个RefreshRoutesEvent事件\"]},\"40\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"41\":{\"h\":\"Redisson\"},\"42\":{\"h\":\"Redis\"},\"43\":{\"h\":\"Spring\"}},\"dirtCount\":0,\"index\":[[\"缓存等\",{\"1\":{\"39\":1}}],[\"自定义实现routedefinitionrepository接口\",{\"1\":{\"39\":1}}],[\"自学和工作期间有着记录笔记的习惯\",{\"1\":{\"0\":1}}],[\"或fetch\",{\"1\":{\"39\":1}}],[\"或者\",{\"1\":{\"3\":1,\"4\":1,\"28\":1}}],[\"或者阻塞时间到了\",{\"1\":{\"3\":1}}],[\"或者当前线程被中断\",{\"1\":{\"3\":1}}],[\"监听到事件后\",{\"1\":{\"39\":2}}],[\"监听refreshroutesevent事件\",{\"1\":{\"39\":1}}],[\"统一提供routes\",{\"1\":{\"39\":1}}],[\"过滤器工厂和断言工厂\",{\"1\":{\"39\":1}}],[\"过期时间\",{\"1\":{\"3\":1,\"5\":1}}],[\"过期时间和当前线程标识作为argv传入\",{\"1\":{\"3\":1}}],[\"现在如何对路由配置进行增加删除的入口已经找到\",{\"1\":{\"39\":1}}],[\"维护保存在routes属性中的routedefinition信息\",{\"1\":{\"39\":1}}],[\"接下去看配置类的加载内容\",{\"1\":{\"39\":1}}],[\"接下去执行lambda内容createbean\",{\"1\":{\"28\":1}}],[\"组合所有routedefinitionlocator\",{\"1\":{\"39\":1}}],[\"都是间接实现routedefinitionlocator\",{\"1\":{\"39\":1}}],[\"都会通过适配器模式转换为对应的methodinterceptor类\",{\"1\":{\"10\":1}}],[\"一个routelocator的包装类\",{\"1\":{\"39\":1}}],[\"一个routedefinitionlocator包装类\",{\"1\":{\"39\":1}}],[\"一般的aop动态代理是依靠\",{\"1\":{\"34\":1}}],[\"一般的advice\",{\"1\":{\"10\":1}}],[\"一般为datasourcetransactionmanager\",{\"1\":{\"23\":1}}],[\"注册了cachingroutelocator\",{\"1\":{\"39\":1}}],[\"注册一个propertiesroutedefinitionlocator类将网关配置文件信息加载到内存中\",{\"1\":{\"39\":1}}],[\"注意\",{\"1\":{\"25\":1}}],[\"注意甄别\",{\"1\":{\"0\":1}}],[\"加载gatewayautoconfiguration时\",{\"1\":{\"39\":1}}],[\"加锁保证单例性\",{\"1\":{\"27\":1}}],[\"项目启动\",{\"1\":{\"39\":1}}],[\"静态路由的配置对象routedefinition\",{\"1\":{\"39\":1}}],[\"路由定义定位器\",{\"1\":{\"39\":1}}],[\"路由配置主要使用yml配置文件和编码两种形式\",{\"1\":{\"39\":1}}],[\"路由装配过程\",{\"0\":{\"39\":1}}],[\"后置处理器处理时生成aop代理\",{\"1\":{\"36\":1}}],[\"后续通过该数据持有对象获取连接\",{\"1\":{\"23\":1}}],[\"随后进入检查当前bean是否依赖其他bean\",{\"1\":{\"34\":1}}],[\"随后取消订阅\",{\"1\":{\"4\":1}}],[\"yisu\",{\"1\":{\"34\":1}}],[\"yes\",{\"1\":{\"27\":1}}],[\"无法应用spring的三层缓存\",{\"1\":{\"33\":1}}],[\"构造routedefinition\",{\"1\":{\"39\":1}}],[\"构造器注入的循环依赖无法解决\",{\"0\":{\"33\":1}}],[\"构造partiallycomparableadvisorholder\",{\"1\":{\"19\":1}}],[\"层次分\",{\"1\":{\"31\":1}}],[\"我的理解就是\",{\"1\":{\"31\":1}}],[\"我们知道在spring的第三层缓存中放着objectfactory对象\",{\"1\":{\"34\":1}}],[\"我们来看一下创建bean部分\",{\"1\":{\"28\":1}}],[\"我们使用mybatis时\",{\"1\":{\"24\":1}}],[\"我们回看提交模板方法中\",{\"1\":{\"23\":1}}],[\"至此\",{\"1\":{\"39\":1}}],[\"至此开启事务结束\",{\"1\":{\"23\":1}}],[\"至少需要二级缓存\",{\"1\":{\"30\":1}}],[\"想使用一级缓存解决循环依赖不合理\",{\"1\":{\"30\":1}}],[\"放在实例化后无法解决代理对象的循环依赖问题\",{\"1\":{\"30\":1}}],[\"放在初始化后就无法解决循环依赖\",{\"1\":{\"30\":1}}],[\"放进第二个map\",{\"1\":{\"27\":1}}],[\"什么阶段存放\",{\"1\":{\"30\":1}}],[\"填充依赖属性\",{\"1\":{\"30\":1}}],[\"能给解决简单对象的循环依赖问题\",{\"1\":{\"30\":1}}],[\"引用不变的情况下\",{\"1\":{\"30\":1}}],[\"只会通过smartinstantiationawarebeanpostprocessor类的实现类的后置处理器来获取代理对象\",{\"1\":{\"34\":1}}],[\"只会从第二\",{\"1\":{\"29\":1}}],[\"只是改方法只给trylock\",{\"1\":{\"4\":1}}],[\"校验\",{\"1\":{\"29\":1}}],[\"得到的代理对象\",{\"1\":{\"29\":1}}],[\"应为singletonscurrentlyincreation集合已经存在a对象的beanname而添加失败\",{\"1\":{\"29\":1}}],[\"循环就开始\",{\"1\":{\"29\":1}}],[\"循环依赖会导致内存溢出\",{\"1\":{\"25\":1}}],[\"循环依赖\",{\"0\":{\"25\":1}}],[\"初次获取b对象\",{\"1\":{\"29\":1}}],[\"初始化阶段时不会获取代理对象的\",{\"1\":{\"34\":1}}],[\"初始化bean\",{\"1\":{\"30\":1}}],[\"初始化后\",{\"1\":{\"29\":1,\"34\":1}}],[\"初始化\",{\"1\":{\"29\":1}}],[\"初始化事务同步回调内容\",{\"1\":{\"23\":1}}],[\"初始值为30000ms\",{\"1\":{\"3\":1}}],[\"去获取需要属性注入的b对象\",{\"1\":{\"29\":1}}],[\"依赖注入就在这完成\",{\"1\":{\"29\":1}}],[\"属性填充成功后\",{\"1\":{\"29\":1}}],[\"属性填充\",{\"1\":{\"29\":1}}],[\"属性的类名\",{\"1\":{\"26\":1}}],[\"往第三个map中存入beanname对应的一个objectfactory\",{\"1\":{\"29\":1}}],[\"往singletonscurrentlyincreation中添加了当前beanname\",{\"1\":{\"28\":1}}],[\"生成二级缓存中早期引用的方法\",{\"1\":{\"29\":1}}],[\"配置在此处影响了三级缓存\",{\"1\":{\"29\":1}}],[\"处于创建中\",{\"1\":{\"29\":1}}],[\"处理事务的增强方法都是在代理对象的方法中\",{\"1\":{\"21\":1}}],[\"然后交给后续的filteringwebhandler\",{\"1\":{\"39\":1}}],[\"然后进入docreatebean\",{\"1\":{\"28\":1}}],[\"然后将连接设为事务手动提交\",{\"1\":{\"23\":1}}],[\"具体查看一下\",{\"1\":{\"28\":1}}],[\"三层缓存中并不存在任何相关对象\",{\"1\":{\"28\":1}}],[\"三个常用的传播行为\",{\"1\":{\"23\":1}}],[\"即如果第二层缓存不存在\",{\"1\":{\"28\":1}}],[\"即重入次数+1\",{\"1\":{\"3\":1}}],[\"发现需要注入a对象\",{\"1\":{\"29\":1}}],[\"发现使用的是getsingleton1\",{\"1\":{\"28\":1}}],[\"发布一个refreshroutesevent事件\",{\"1\":{\"39\":1}}],[\"发布解锁消息\",{\"1\":{\"5\":1}}],[\"发布解锁消息通道\",{\"1\":{\"5\":1}}],[\"发布消息命令\",{\"1\":{\"5\":1}}],[\"追进去查看\",{\"1\":{\"28\":1}}],[\"假设只有的第一层map\",{\"1\":{\"30\":1}}],[\"假设a与b循环依赖\",{\"1\":{\"28\":1}}],[\"假设当前持有锁的线程发起解锁lua脚本的执行\",{\"1\":{\"5\":1}}],[\"称为getsingleton1\",{\"1\":{\"27\":1}}],[\"quick\",{\"1\":{\"27\":1}}],[\"qq\",{\"1\":{\"21\":1}}],[\"中\",{\"1\":{\"27\":1}}],[\"尚未填充属性\",{\"1\":{\"27\":1}}],[\"众所周知\",{\"1\":{\"27\":1}}],[\"防止循环依赖后不断创建新对象导致栈内存溢出\",{\"1\":{\"26\":1}}],[\"模拟spring解决循环依赖的缓存\",{\"1\":{\"26\":1}}],[\"添加配置spring\",{\"1\":{\"25\":1}}],[\"时会先去执行属性\",{\"1\":{\"25\":1}}],[\"时间单位\",{\"1\":{\"3\":1}}],[\"→\",{\"1\":{\"25\":2}}],[\"类b也依赖类a\",{\"1\":{\"25\":1}}],[\"类a依赖类b\",{\"1\":{\"25\":1}}],[\"类没有被\",{\"1\":{\"21\":1}}],[\"子线程2\",{\"1\":{\"24\":1}}],[\"子线程1\",{\"1\":{\"24\":1}}],[\"子事务中将其置为true\",{\"1\":{\"23\":1}}],[\"子事务加入父事务没有开启新事物\",{\"1\":{\"23\":1}}],[\"子事务在开启的过程中dogettransaction\",{\"1\":{\"23\":1}}],[\"例\",{\"1\":{\"24\":1}}],[\"多线程下spring声明式事务的失效原因是线程之间的数据隔离\",{\"1\":{\"24\":1}}],[\"多线程下事务的处理\",{\"0\":{\"24\":1}}],[\"多次的删除锁命令都会得到删除成功\",{\"1\":{\"5\":1}}],[\"还没有对其中的属性进行填充\",{\"1\":{\"29\":1}}],[\"还是正常抛出\",{\"1\":{\"23\":1}}],[\"还通过阻塞锁剩余ttl\",{\"1\":{\"4\":1}}],[\"匹对成功执行回滚操作\",{\"1\":{\"23\":1}}],[\"匹对失败直接执行提交的操作\",{\"1\":{\"23\":1}}],[\"匹对异常runtimeexception或者error\",{\"1\":{\"23\":1}}],[\"匹配相应的过滤器执行相应内容\",{\"1\":{\"39\":1}}],[\"匹配成功\",{\"1\":{\"15\":1}}],[\"匹配又分classfilter匹配对象和methodmatcher匹配方法\",{\"1\":{\"9\":1}}],[\"父事务执行提交时才会真正提交\",{\"1\":{\"23\":1}}],[\"此时能够从三级缓存中获取工厂对象\",{\"1\":{\"29\":1}}],[\"此时a是初次创建\",{\"1\":{\"28\":1}}],[\"此时不管父事务的原方法是捕获了异常\",{\"1\":{\"23\":1}}],[\"此时重新开始执行上面分析的事务开启方法\",{\"1\":{\"23\":1}}],[\"此处依旧获取null\",{\"1\":{\"29\":1}}],[\"此处也是循环依赖检测的一个关键点\",{\"1\":{\"28\":1}}],[\"此处产生的循环依赖无法解决\",{\"1\":{\"28\":1}}],[\"此处就是为什么方法中抛出的异常与定义的回滚异常不一致时\",{\"1\":{\"23\":1}}],[\"此处判断为true\",{\"1\":{\"23\":1}}],[\"此处是datasourcetransactionmanager的实现\",{\"1\":{\"23\":1}}],[\"此处暂时研究spring事务的创建\",{\"1\":{\"23\":1}}],[\"此处我也十分不理解\",{\"1\":{\"5\":1}}],[\"此处如果转变完成状态时任务刚好完成了\",{\"1\":{\"4\":1}}],[\"才能提交\",{\"1\":{\"23\":1}}],[\"手动commit\",{\"1\":{\"23\":1}}],[\"存放刚实例化后的bean\",{\"1\":{\"30\":1}}],[\"存放单例对象工厂对象\",{\"1\":{\"27\":1}}],[\"存放原始的\",{\"1\":{\"27\":1}}],[\"存放的是当前需要操作的事务信息\",{\"1\":{\"23\":1}}],[\"存在依赖其他bean抛异常beancurrentlyincreationexception\",{\"1\":{\"34\":1}}],[\"存在直接取出来set进去\",{\"1\":{\"26\":1}}],[\"存在直接返回实例bean\",{\"1\":{\"26\":1}}],[\"存在\",{\"1\":{\"5\":1}}],[\"隔离级别\",{\"1\":{\"23\":1}}],[\"激活状态\",{\"1\":{\"23\":1}}],[\"连接持有对象活动事务标志设上\",{\"1\":{\"23\":1}}],[\"保存着当前事务的属性\",{\"1\":{\"23\":1}}],[\"保证了循环依赖中注入的引用和bean创建好后的引用一致\",{\"1\":{\"29\":1}}],[\"保证了服务端只要删除了一次锁\",{\"1\":{\"5\":1}}],[\"保证单例性\",{\"1\":{\"27\":1}}],[\"保证正常回滚\",{\"1\":{\"24\":1}}],[\"保证前面判断已存在事务的正确性\",{\"1\":{\"23\":1}}],[\"保证命令结果一致性\",{\"1\":{\"5\":1}}],[\"保证重入锁并且用户未设置过期时间时延用初始的过期时间\",{\"1\":{\"3\":1}}],[\"继续查看配置类\",{\"1\":{\"39\":1}}],[\"继续查找配置\",{\"1\":{\"39\":1}}],[\"继续执行preparesynchronization方法\",{\"1\":{\"23\":1}}],[\"继续执行到\",{\"1\":{\"23\":1}}],[\"继续执行\",{\"1\":{\"23\":1}}],[\"继续调用后续拦截器\",{\"1\":{\"16\":1}}],[\"条件显然不成立\",{\"1\":{\"23\":1}}],[\"声明式事务方法第一次执行时\",{\"1\":{\"23\":1}}],[\"数据连接是否存在活动事务标志\",{\"1\":{\"23\":1}}],[\"分支内是对于子事务如何处理的入口\",{\"1\":{\"23\":1}}],[\"分析一下解锁lua脚本\",{\"1\":{\"5\":1}}],[\"回到案例\",{\"1\":{\"23\":1}}],[\"回到invokewithintransaction执行带代理的原方法\",{\"1\":{\"23\":1}}],[\"回到starttransaction\",{\"1\":{\"23\":1}}],[\"回到gettransaction继续执行\",{\"1\":{\"23\":1}}],[\"回滚中\",{\"1\":{\"23\":1}}],[\"回滚相关执行流程\",{\"1\":{\"23\":1}}],[\"回滚\",{\"1\":{\"23\":1}}],[\"创建的都是新对象\",{\"1\":{\"31\":1}}],[\"创建实例\",{\"1\":{\"30\":1}}],[\"创建aop或者返回原始对象的方法\",{\"1\":{\"29\":1}}],[\"创建bean的具体实现\",{\"1\":{\"29\":1}}],[\"创建好的对象\",{\"1\":{\"27\":1}}],[\"创建该类的bean\",{\"1\":{\"26\":1}}],[\"创建一个对象时你会获得一个栈溢出的错误\",{\"1\":{\"25\":1}}],[\"创建一个事务对象存放当前事务的数据连接持有对象\",{\"1\":{\"23\":1}}],[\"创建instantiationmodelawarepointcutadvisorimpl对象时\",{\"1\":{\"18\":1}}],[\"传入事务属性\",{\"1\":{\"23\":1}}],[\"传播行为\",{\"0\":{\"22\":1}}],[\"👇来看一下事务开启做了什么\",{\"1\":{\"23\":1}}],[\"👇当执行\",{\"1\":{\"23\":1}}],[\"包含了整个事务处理的过程\",{\"1\":{\"23\":1}}],[\"核心在其父类的invokewithintransaction方法中\",{\"1\":{\"23\":1}}],[\"测试事务\",{\"1\":{\"23\":3,\"24\":4}}],[\"测试事务3\",{\"1\":{\"23\":1,\"24\":1}}],[\"案例的子事务传播行为是默认的propagation\",{\"1\":{\"23\":1}}],[\"案例\",{\"1\":{\"23\":1}}],[\"提前曝光的单例对象的cache\",{\"1\":{\"27\":1}}],[\"提交一定要是事务状态为新事务时\",{\"1\":{\"23\":1}}],[\"提交由事务管理器抽象类提供模板方法\",{\"1\":{\"23\":1}}],[\"提交\",{\"1\":{\"23\":2}}],[\"提示\",{\"1\":{\"0\":1}}],[\"需要实现动态路由\",{\"1\":{\"39\":1}}],[\"需要明确spring事务帮我们做了什么\",{\"1\":{\"23\":1}}],[\"需要通过参数匹配的情况\",{\"1\":{\"15\":1}}],[\"则抛出异常\",{\"1\":{\"22\":1}}],[\"则创建一个interceptoranddynamicmethodmatcher对象\",{\"1\":{\"15\":1}}],[\"总是非事务地执行\",{\"1\":{\"22\":1}}],[\"724480\",{\"1\":{\"34\":1}}],[\"7\",{\"1\":{\"22\":1}}],[\"6\",{\"1\":{\"22\":1,\"25\":1,\"29\":1}}],[\"外部事务挂起等待内部方法执行\",{\"1\":{\"22\":1}}],[\"外部事务也回滚\",{\"1\":{\"22\":1}}],[\"外部方法\",{\"1\":{\"22\":1}}],[\"对象\",{\"1\":{\"27\":1}}],[\"对事务状态做了许多判断\",{\"1\":{\"23\":1}}],[\"对事务管理员\",{\"1\":{\"22\":1}}],[\"对于用户来说调用proceed\",{\"1\":{\"16\":1}}],[\"参考\",{\"1\":{\"21\":1,\"34\":1}}],[\"参数传入reflectivemethodinvocation对象自身\",{\"1\":{\"16\":1}}],[\"参数分别为超时时间\",{\"1\":{\"3\":1}}],[\"解决循环依赖的简单思路\",{\"0\":{\"26\":1}}],[\"解决\",{\"1\":{\"21\":1}}],[\"解锁消息\",{\"1\":{\"5\":1}}],[\"解锁标识\",{\"1\":{\"5\":1}}],[\"解锁\",{\"1\":{\"5\":1}}],[\"指向的当然时原对象\",{\"1\":{\"21\":1}}],[\"增强方法在代理对象的方法中\",{\"1\":{\"21\":1}}],[\"增加了\",{\"1\":{\"4\":1}}],[\"原方法抛出异常时\",{\"1\":{\"23\":1}}],[\"原因\",{\"1\":{\"21\":1}}],[\"原重试等待时间\",{\"1\":{\"4\":1}}],[\"为什么二级缓存不够\",{\"0\":{\"31\":1}}],[\"为什么不使用一级缓存\",{\"1\":{\"30\":1}}],[\"为什么一级缓存不行\",{\"0\":{\"30\":1}}],[\"为什么this指的是对象本身而不是代理对象呢\",{\"1\":{\"21\":1}}],[\"为入口\",{\"1\":{\"28\":1}}],[\"为事务的连接持有对象设置了一个回滚标记\",{\"1\":{\"23\":1}}],[\"为false\",{\"1\":{\"23\":1}}],[\"为了修复以下问题时添加的\",{\"1\":{\"5\":1}}],[\"事务其实就是同一连接中的数据库操作的一致性\",{\"1\":{\"24\":1}}],[\"事务都会回滚\",{\"1\":{\"23\":1}}],[\"事务失效的原因\",{\"1\":{\"23\":1}}],[\"事务管理器的提交方法其实就是获取存储的事务连接对象\",{\"1\":{\"23\":1}}],[\"事务对象\",{\"1\":{\"23\":1}}],[\"事务隔离级别等\",{\"1\":{\"23\":1}}],[\"事务\",{\"1\":{\"23\":1}}],[\"事务传播行为等待\",{\"1\":{\"23\":1}}],[\"事务协调员\",{\"1\":{\"22\":1}}],[\"事务是由aop代理来实现的\",{\"1\":{\"21\":1}}],[\"事务默认只在抛出运行时异常\",{\"1\":{\"21\":1}}],[\"失效的本质是\",{\"1\":{\"21\":1}}],[\"的初始化又会去执行aservice\",{\"1\":{\"25\":1}}],[\"的初始化\",{\"1\":{\"25\":2}}],[\"的\",{\"1\":{\"23\":2}}],[\"的方式调用事务存在事务的方法\",{\"1\":{\"21\":1}}],[\"的compareto方法\",{\"1\":{\"19\":1}}],[\"xxx\",{\"1\":{\"21\":1}}],[\"同一个类中\",{\"1\":{\"21\":1}}],[\"异常被捕获\",{\"1\":{\"21\":1}}],[\"异步订阅解锁消息\",{\"1\":{\"3\":1}}],[\"管理\",{\"1\":{\"21\":1}}],[\"五种失效情况\",{\"0\":{\"21\":1}}],[\"方中还是调用了default\",{\"1\":{\"19\":1}}],[\"方法得到代理后的引用\",{\"1\":{\"29\":1}}],[\"方法是通过获取transactionsynchronizationmanager中配置的事务提交前执行方法\",{\"1\":{\"23\":1}}],[\"方法时\",{\"1\":{\"23\":1,\"29\":1}}],[\"方法内部使用routelocator重新获取route\",{\"1\":{\"39\":1}}],[\"方法内部使用this\",{\"1\":{\"21\":1}}],[\"方法内部调用\",{\"1\":{\"21\":1}}],[\"方法内部没有重试\",{\"1\":{\"4\":1}}],[\"方法不是public修饰\",{\"1\":{\"21\":1}}],[\"方法最终是调用beanfactoryaspectinstancefactory的getorder\",{\"1\":{\"19\":1}}],[\"方法调用的是reflectiveaspectjadvisorfactory类实现的方法\",{\"1\":{\"18\":1}}],[\"方法参数\",{\"1\":{\"16\":1}}],[\"方法对象\",{\"1\":{\"16\":1}}],[\"方法匹配\",{\"1\":{\"15\":1}}],[\"方法完成\",{\"1\":{\"15\":1}}],[\"方法中能够获取同一持有对象\",{\"1\":{\"23\":1}}],[\"方法中可以看到eligibleadvisors\",{\"1\":{\"19\":1}}],[\"方法中\",{\"1\":{\"18\":1,\"29\":1}}],[\"方法中的createproxy\",{\"1\":{\"36\":1}}],[\"方法中的关键部分\",{\"1\":{\"14\":1}}],[\"方法中的第三个参数invocationhandler的invoke方法实现的\",{\"1\":{\"14\":1}}],[\"方法中实现\",{\"1\":{\"14\":1}}],[\"方法可以发现最终调用org\",{\"1\":{\"12\":1}}],[\"方法获取aop代理对象\",{\"1\":{\"36\":1}}],[\"方法获取aopproxy接口类的实现类\",{\"1\":{\"12\":1}}],[\"方法获取代理对象\",{\"1\":{\"12\":1}}],[\"方法获取目标的aop代理类\",{\"1\":{\"12\":1}}],[\"方法\",{\"1\":{\"4\":1,\"12\":1,\"16\":2,\"18\":1,\"36\":1,\"39\":1}}],[\"方法没有设置过期时间\",{\"1\":{\"3\":1}}],[\"但是getearlybeanreference方法中\",{\"1\":{\"34\":1}}],[\"但是构造器的注入是发生在实例化期间\",{\"1\":{\"33\":1}}],[\"但是此处不会生成获取早期引用方法\",{\"1\":{\"29\":1}}],[\"但是在partialorder\",{\"1\":{\"19\":1}}],[\"但是前一次的命令已经被redis执行删除了锁\",{\"1\":{\"5\":1}}],[\"偏序排序没有深入研究\",{\"1\":{\"19\":1}}],[\"偏序排序的结构为空时\",{\"1\":{\"19\":1}}],[\"赋值为\",{\"1\":{\"19\":1}}],[\"实则调用的abstractautoproxycreator类的方法\",{\"1\":{\"36\":1}}],[\"实例化后处理循环依赖的关键点\",{\"1\":{\"29\":1}}],[\"实例化没有深入研究\",{\"1\":{\"29\":1}}],[\"实例化\",{\"1\":{\"29\":1}}],[\"实现getroutedefinitions\",{\"1\":{\"39\":1}}],[\"实现了applicationlistener\",{\"1\":{\"39\":1}}],[\"实现了partialcomparable\",{\"1\":{\"19\":1}}],[\"实现方法\",{\"1\":{\"28\":1}}],[\"实质调用的是abstractautoproxycreator的方法\",{\"1\":{\"18\":1}}],[\"进入else\",{\"1\":{\"28\":1}}],[\"进入处理\",{\"1\":{\"23\":1}}],[\"进入方法\",{\"1\":{\"19\":1}}],[\"进行bean的后置处理器处理\",{\"1\":{\"29\":1}}],[\"进行事务提交前的前置操作\",{\"1\":{\"23\":1}}],[\"进行偏序排序\",{\"1\":{\"19\":1}}],[\"进行方法匹配\",{\"1\":{\"15\":1}}],[\"其实就是判断\",{\"1\":{\"23\":1}}],[\"其实是其父类的父类org\",{\"1\":{\"12\":1}}],[\"其中通过annotationawareaspectjautoproxycreator\",{\"1\":{\"36\":1}}],[\"其中会判断该bean是否需要创建aop\",{\"1\":{\"27\":1}}],[\"其中triggerbeforecommit\",{\"1\":{\"23\":1}}],[\"其中涉及到许多配置和属性读取\",{\"1\":{\"23\":1}}],[\"其中的dependson依赖处理\",{\"1\":{\"28\":1}}],[\"其中的name就是切面类bean的name\",{\"1\":{\"19\":1}}],[\"其中的getadvicesandadvisorsforbean\",{\"1\":{\"19\":1}}],[\"其中的wrapifnecessary\",{\"1\":{\"19\":1}}],[\"其是间接实现了ordered接口的\",{\"1\":{\"19\":1}}],[\"找到目标对象的aop代理对象生成的后置处理方法abstractautoproxycreator的postprocessafterinitialization\",{\"1\":{\"19\":1}}],[\"内容在该类静态代码块中复制\",{\"1\":{\"18\":1}}],[\"内部事务产生回滚时\",{\"1\":{\"22\":1}}],[\"内部方法的事务都不生效\",{\"1\":{\"22\":1}}],[\"内部方法就不使用事务\",{\"1\":{\"22\":1}}],[\"内部方法创建自己独立的事务执行\",{\"1\":{\"22\":1}}],[\"内部方法创建自己独立的事务\",{\"1\":{\"22\":2}}],[\"内部方法事务加入\",{\"1\":{\"22\":2}}],[\"内部方法事务成为外部事务的嵌套子事务\",{\"1\":{\"22\":1}}],[\"内部方法事务就创建自己的事务\",{\"1\":{\"22\":1}}],[\"内部方法事务将加入外部事务\",{\"1\":{\"22\":1}}],[\"内部方法\",{\"1\":{\"22\":1}}],[\"内部就是annotationawareordercomparator\",{\"1\":{\"19\":1}}],[\"内部其实先去调用剩余的拦截器链才最后调用的目标原方法\",{\"1\":{\"16\":1}}],[\"内部也是使用\",{\"1\":{\"16\":1}}],[\"内部使用abstractaspectjadvice的模板方法invokeadvicemethod\",{\"1\":{\"16\":1}}],[\"内部使用\",{\"1\":{\"3\":1}}],[\"主要通过annotationawareaspectjautoproxycreator类后置处理器\",{\"1\":{\"36\":1}}],[\"主要实现方法\",{\"1\":{\"29\":1}}],[\"主要到执行了methods\",{\"1\":{\"18\":1}}],[\"主要用于\",{\"1\":{\"9\":1}}],[\"语句给出的method集合就是按照around\",{\"1\":{\"18\":1}}],[\"经过调用栈发现在切面类bean的annotationawareaspectjautoproxycreator后置处理器的postprocessbeforeinstantiation\",{\"1\":{\"18\":1}}],[\"首先得弄清楚advice类在何时创建\",{\"1\":{\"18\":1}}],[\"首先判断解锁标识\",{\"1\":{\"5\":1}}],[\"肯定进行了排序\",{\"1\":{\"18\":1}}],[\"第三个map即解决存在aop情况下的循环依赖问题\",{\"1\":{\"31\":1}}],[\"第二参数为false\",{\"1\":{\"29\":1}}],[\"第二个参数为true\",{\"1\":{\"28\":1}}],[\"第二个参数放set的值\",{\"1\":{\"26\":1}}],[\"第二次排序\",{\"0\":{\"19\":1}}],[\"第二次的命令\",{\"1\":{\"5\":1}}],[\"第一个map中没有\",{\"1\":{\"27\":1}}],[\"第一参数是表示\",{\"1\":{\"26\":1}}],[\"第一次执行时\",{\"1\":{\"23\":1}}],[\"第一次排序\",{\"0\":{\"18\":1}}],[\"如上所述\",{\"1\":{\"39\":1}}],[\"如上述a切面的around方法\",{\"1\":{\"16\":1}}],[\"如代理对象的创建\",{\"1\":{\"29\":1}}],[\"如\",{\"1\":{\"23\":1}}],[\"如当前事务的名称\",{\"1\":{\"23\":1}}],[\"如事务管理器\",{\"1\":{\"23\":1}}],[\"如果对象需要代理就可以通过getearlybeanreference方法获取\",{\"1\":{\"34\":1}}],[\"如果二级缓存直接存储objectfactory对象\",{\"1\":{\"31\":1}}],[\"如果只有一级缓存\",{\"1\":{\"30\":1}}],[\"如果一致\",{\"1\":{\"29\":1}}],[\"如果允许早期暴露单例\",{\"1\":{\"29\":1}}],[\"如果没有打开循环依赖配置\",{\"1\":{\"29\":1}}],[\"如果循环依赖没有开启\",{\"1\":{\"29\":1}}],[\"如果bean存在实现了smartinstantiationawarebeanpostprocessor类的后置处理器\",{\"1\":{\"29\":1}}],[\"如果当前bean为单例\",{\"1\":{\"29\":1}}],[\"如果当前方法中没有调用其他存在事务的方法\",{\"1\":{\"23\":1}}],[\"如果半成品也没有\",{\"1\":{\"27\":1}}],[\"如果存在循环依赖\",{\"1\":{\"27\":1}}],[\"如果需要开启\",{\"1\":{\"25\":1}}],[\"如果父事务将子事务的异常捕获且没有抛出新异常\",{\"1\":{\"23\":1}}],[\"如果父事务真正抛出异常\",{\"1\":{\"23\":1}}],[\"如果注解没有定义回滚异常\",{\"1\":{\"23\":1}}],[\"如果外部方法存在事务\",{\"1\":{\"22\":1}}],[\"如果目标方法存在通知\",{\"1\":{\"16\":1}}],[\"如果是同一个切面类中的是按照既定的around\",{\"1\":{\"19\":1}}],[\"如果是\",{\"1\":{\"15\":1}}],[\"如果是动态匹配\",{\"1\":{\"15\":1}}],[\"如果是null\",{\"1\":{\"5\":1}}],[\"如果就加了一次锁\",{\"1\":{\"5\":1}}],[\"如果次数小于等于零\",{\"1\":{\"5\":1}}],[\"如果次数还大于零\",{\"1\":{\"5\":1}}],[\"如果成功获取\",{\"1\":{\"5\":1}}],[\"如果completeexceptionally的转变完成状态成功\",{\"1\":{\"4\":1}}],[\"如果任务未完成\",{\"1\":{\"4\":1}}],[\"如果超过了重试等待时时间\",{\"1\":{\"4\":1}}],[\"如果未设置过期时间会通过scheduleexpirationrenewal开启了定时任务续期\",{\"1\":{\"3\":1}}],[\"如果用户未设置过期时间\",{\"1\":{\"3\":1}}],[\"如果lock\",{\"1\":{\"3\":1}}],[\"如果定时任务启动前\",{\"1\":{\"3\":1}}],[\"因为在二级缓存中已经存在代理对象的引用\",{\"1\":{\"34\":1}}],[\"因为使用\",{\"1\":{\"34\":1}}],[\"因为b注入a时使用的二级缓存objectfactory对象创建a\",{\"1\":{\"31\":1}}],[\"因为相关后置处理器的后置处理方法中\",{\"1\":{\"29\":1}}],[\"因为调用\",{\"1\":{\"25\":1}}],[\"因为第一个事务开启时将连接持有对象与线程绑定由transactionsynchronizationmanager管理\",{\"1\":{\"23\":1}}],[\"因为对于around类似的通知\",{\"1\":{\"16\":1}}],[\"因为after是无论原方法执行成功与否都需要执行的逻辑\",{\"1\":{\"16\":1}}],[\"因此在此处\",{\"1\":{\"34\":1}}],[\"因此\",{\"1\":{\"23\":1}}],[\"因此使用this对象本身调用方法aop会失效\",{\"1\":{\"21\":1}}],[\"因此aop代理对各通知的调用在jdkdynamicaopproxy的invoke\",{\"1\":{\"14\":1}}],[\"因此想整理补充形成目录较分明的文档\",{\"1\":{\"0\":1}}],[\"先从第一个map中获取成品bean\",{\"1\":{\"27\":1}}],[\"先看看提交\",{\"1\":{\"23\":1}}],[\"先继续调用后续拦截器为了最后执行原方法\",{\"1\":{\"16\":1}}],[\"先调用before类型的advice\",{\"1\":{\"16\":1}}],[\"拦截链中的各拦截器\",{\"1\":{\"16\":1}}],[\"拦截器链的调用由reflectivemethodinvocation的proceed\",{\"1\":{\"16\":1}}],[\"拦截器链调用\",{\"0\":{\"16\":1}}],[\"拦截器链是通过advisedsupport中持有的advisors\",{\"1\":{\"15\":1}}],[\"猫吃鱼\",{\"1\":{\"16\":1}}],[\"以下aop切面示例\",{\"1\":{\"16\":1}}],[\"以上属于静态匹配\",{\"1\":{\"9\":1}}],[\"jc\",{\"1\":{\"34\":1}}],[\"join\",{\"1\":{\"24\":1}}],[\"joinpointmatch\",{\"1\":{\"16\":1}}],[\"joinpoint\",{\"1\":{\"16\":4}}],[\"jpm\",{\"1\":{\"16\":2}}],[\"just\",{\"1\":{\"16\":1}}],[\"jdkdynamicaopproxy也确实实现了invocationhandler接口\",{\"1\":{\"14\":1}}],[\"jdkdynamicaopproxy使用jdk动态代理实现aop代理时\",{\"1\":{\"14\":1}}],[\"jdkdynamicaopproxy的invoke\",{\"0\":{\"14\":1}}],[\"jdk动态代理中\",{\"1\":{\"14\":1}}],[\"jdk动态代理创建\",{\"1\":{\"12\":1}}],[\"jdkregexpmethodpointcut\",{\"1\":{\"9\":1}}],[\"直接回滚\",{\"1\":{\"23\":1}}],[\"直接回滚或者提交\",{\"1\":{\"23\":1}}],[\"直接调用各拦截器的invoke方法\",{\"1\":{\"16\":1}}],[\"直接返回获取锁的成功与否\",{\"1\":{\"4\":1}}],[\"完成\",{\"1\":{\"16\":1}}],[\"完成的话会取消这个定时任务\",{\"1\":{\"3\":1}}],[\"当进入到第三阶段初始化时才会通过asyncannotationbeanpostprocessor获取代理对象\",{\"1\":{\"34\":1}}],[\"当通过\",{\"1\":{\"25\":1}}],[\"当原方法捕获了异常但是不抛出新异常\",{\"1\":{\"23\":1}}],[\"当原方法执行时\",{\"1\":{\"23\":1}}],[\"当判断已存在事务时\",{\"1\":{\"23\":1}}],[\"当内部事务回滚时只会回滚到内部事务执行前状态\",{\"1\":{\"22\":1}}],[\"当外部方法存在事务\",{\"1\":{\"22\":2}}],[\"当外部方法存在事务时\",{\"1\":{\"22\":3}}],[\"当外部方法不存在事务时\",{\"1\":{\"22\":5}}],[\"当目标对象在后置处理器中进行aop代理创建时\",{\"1\":{\"19\":1}}],[\"当拦截器链全部调用完毕\",{\"1\":{\"16\":1}}],[\"当前连接持有对象中的回滚标记是否为true\",{\"1\":{\"23\":1}}],[\"当前事务开启状态\",{\"1\":{\"23\":1}}],[\"当前获取了锁的线程在解锁时\",{\"1\":{\"5\":1}}],[\"当前时间\",{\"1\":{\"4\":1}}],[\"当前尝试获取锁id\",{\"1\":{\"3\":1}}],[\"来看一下具体做了啥\",{\"1\":{\"39\":1}}],[\"来看一下inmemoryroutedefinitionrepository类\",{\"1\":{\"39\":1}}],[\"来看一下第二次获取a有什么不同\",{\"1\":{\"29\":1}}],[\"来看看回滚\",{\"1\":{\"23\":1}}],[\"来执行不同的逻辑\",{\"1\":{\"23\":1}}],[\"来执行after方法\",{\"1\":{\"16\":1}}],[\"来判断是否已存在事务\",{\"1\":{\"23\":1}}],[\"来生成和缓存当前aspect中的advisor\",{\"1\":{\"18\":1}}],[\"来进行拦截器链的遍历调用\",{\"1\":{\"16\":1}}],[\"来避免线程不必要的尝试造成性能浪费\",{\"1\":{\"4\":1}}],[\"来避免不断重试获取锁的开销\",{\"1\":{\"4\":1}}],[\"在其中由属性routelocator获取route的断言遍历匹配exchange\",{\"1\":{\"39\":1}}],[\"在其他需要注入routedefinitionlocator类的地方\",{\"1\":{\"39\":1}}],[\"在其子类abstractadvisorautoproxycreator的findeligibleadvisors\",{\"1\":{\"19\":1}}],[\"在实际使用中\",{\"1\":{\"39\":1}}],[\"在bean的初始化阶段会根据各后置处理器进行处理\",{\"1\":{\"36\":1}}],[\"在bean生命周期的初始化阶段\",{\"1\":{\"36\":1}}],[\"在此期间三个map中都不会存在可获取的bean\",{\"1\":{\"33\":1}}],[\"在aspectjautoproxyregistrar类中注册annotationawareaspectjautoproxycreator后置处理器\",{\"1\":{\"36\":1}}],[\"在abstractautowirecapablebeanfactory类中的initializebean\",{\"1\":{\"29\":1}}],[\"在aop代理对象执行方法时\",{\"1\":{\"10\":1}}],[\"在本文中将上面的getsingleton\",{\"1\":{\"27\":1}}],[\"在processcommit前其实还有判断\",{\"1\":{\"23\":1}}],[\"在案例的情况下\",{\"1\":{\"23\":1}}],[\"在isexistingtransaction处\",{\"1\":{\"23\":1}}],[\"在第一次排序中我们说到advisor在切面bean初始化时创建\",{\"1\":{\"19\":1}}],[\"在构造器中也创建了advice\",{\"1\":{\"18\":1}}],[\"在reflectivemethodinvocation的proceed\",{\"1\":{\"16\":1}}],[\"在拦截器中再调用proceed\",{\"1\":{\"16\":1}}],[\"看一下具体内容\",{\"1\":{\"39\":1}}],[\"看一下getadvisormethods\",{\"1\":{\"18\":1}}],[\"看一下proceed\",{\"1\":{\"16\":1}}],[\"看看getproxy\",{\"1\":{\"12\":1}}],[\"遍历调用拦截器链\",{\"1\":{\"16\":1}}],[\"遍历通知器\",{\"1\":{\"15\":1}}],[\"目标对象\",{\"1\":{\"16\":1}}],[\"目标方法第一次执行以后都不需要再次做匹配\",{\"1\":{\"9\":1}}],[\"运行时匹配主要指\",{\"1\":{\"15\":1}}],[\"根据需求使用数据库\",{\"1\":{\"39\":1}}],[\"根据getsingleton1\",{\"1\":{\"29\":1}}],[\"根据调试查看调用链\",{\"1\":{\"29\":1}}],[\"根据beandefinition执行实例化前处理器的相关处理\",{\"1\":{\"28\":1}}],[\"根据上述例子拦截器链的顺序\",{\"1\":{\"16\":1}}],[\"根据是否是运行时匹配\",{\"1\":{\"15\":1}}],[\"根据advisor持有的pointcut\",{\"1\":{\"15\":1}}],[\"||\",{\"1\":{\"15\":2}}],[\"gateway中通过routepredicatehandlermapping类\",{\"1\":{\"39\":1}}],[\"globaladvisoradapterregistry\",{\"1\":{\"15\":1}}],[\"generateid\",{\"1\":{\"5\":1}}],[\"getearlybeanreference\",{\"1\":{\"29\":5}}],[\"getentryname\",{\"1\":{\"3\":3}}],[\"getwrappedclass\",{\"1\":{\"29\":1}}],[\"getwrappedinstance\",{\"1\":{\"29\":1}}],[\"getobject\",{\"1\":{\"27\":2}}],[\"getorder\",{\"1\":{\"19\":3}}],[\"getdeclaredfields\",{\"1\":{\"26\":1}}],[\"getdeclaredconstructor\",{\"1\":{\"26\":1}}],[\"getdeclaringclass\",{\"1\":{\"15\":1,\"16\":1}}],[\"getdept\",{\"1\":{\"26\":1}}],[\"getbeanpostprocessorcache\",{\"1\":{\"29\":1}}],[\"getbean\",{\"1\":{\"19\":1,\"26\":7,\"29\":1}}],[\"getjoinpointmatch\",{\"1\":{\"16\":2}}],[\"gettype\",{\"1\":{\"19\":1,\"26\":1}}],[\"getthis\",{\"1\":{\"16\":1}}],[\"gettimeout\",{\"1\":{\"5\":1}}],[\"getarguments\",{\"1\":{\"16\":1}}],[\"getadvisor\",{\"1\":{\"19\":1}}],[\"getadvisors\",{\"1\":{\"15\":1,\"18\":1}}],[\"getadvice\",{\"1\":{\"11\":1}}],[\"getname\",{\"1\":{\"11\":1}}],[\"getnow\",{\"1\":{\"4\":3}}],[\"getproxy\",{\"1\":{\"12\":1}}],[\"getpointcut\",{\"1\":{\"11\":2,\"15\":2}}],[\"getpublishcommand\",{\"1\":{\"5\":1}}],[\"getmethod\",{\"1\":{\"16\":1}}],[\"getmethodmatcher\",{\"1\":{\"9\":1,\"15\":1}}],[\"getmessage\",{\"1\":{\"4\":1}}],[\"getsingleton\",{\"1\":{\"27\":2,\"29\":1}}],[\"getsimplename\",{\"1\":{\"26\":2}}],[\"getstuff\",{\"1\":{\"26\":1}}],[\"getsubscribeservice\",{\"1\":{\"5\":1}}],[\"getservicemanager\",{\"1\":{\"3\":1,\"4\":1,\"5\":3}}],[\"getunlocklatchname\",{\"1\":{\"5\":2}}],[\"getresource\",{\"1\":{\"24\":1}}],[\"getretryattempts\",{\"1\":{\"5\":1}}],[\"getretryinterval\",{\"1\":{\"5\":1}}],[\"getrawname\",{\"1\":{\"3\":5,\"5\":3}}],[\"getcachekey\",{\"1\":{\"29\":1}}],[\"getcause\",{\"1\":{\"5\":2}}],[\"getcurrenttransactionname\",{\"1\":{\"24\":1}}],[\"getclass\",{\"1\":{\"11\":1,\"26\":1,\"29\":1}}],[\"getclassfilter\",{\"1\":{\"9\":1,\"15\":2}}],[\"getchannelname\",{\"1\":{\"5\":1}}],[\"getconfig\",{\"1\":{\"5\":1}}],[\"get阻塞时间到了任务还未完成\",{\"1\":{\"4\":1}}],[\"getfirstthreadid\",{\"1\":{\"3\":1}}],[\"getlockname\",{\"1\":{\"3\":2,\"5\":1}}],[\"getlatch\",{\"1\":{\"3\":4,\"4\":2}}],[\"get\",{\"1\":{\"3\":3,\"4\":2,\"5\":3,\"16\":1,\"26\":2,\"27\":7}}],[\"getinstance\",{\"1\":{\"15\":1}}],[\"getinterceptors\",{\"1\":{\"15\":4}}],[\"getinterceptorsanddynamicinterceptionadvice\",{\"1\":{\"15\":1}}],[\"getinterrupted\",{\"1\":{\"3\":1}}],[\"getid\",{\"1\":{\"3\":1,\"4\":1,\"5\":1}}],[\"上一章节看到\",{\"1\":{\"18\":1}}],[\"上一节中\",{\"1\":{\"14\":1}}],[\"上面获取锁代码耗时\",{\"1\":{\"4\":1}}],[\"代理对象执行方法时\",{\"1\":{\"21\":1}}],[\"代理增强的方法是由\",{\"1\":{\"14\":1}}],[\"代码没有问题\",{\"1\":{\"5\":1}}],[\"大家都知道\",{\"1\":{\"14\":1}}],[\"大致逻辑和lock一致\",{\"1\":{\"4\":1}}],[\"又保证第二个map中存放的始终是半成品bean\",{\"1\":{\"31\":1}}],[\"又调用getbean\",{\"1\":{\"29\":1}}],[\"又进入属性填充\",{\"1\":{\"29\":1}}],[\"又执行了一个声明式事务方法b\",{\"1\":{\"23\":1}}],[\"又是如何根据切面来增强原方法的呢\",{\"1\":{\"13\":1}}],[\"又会调用该方法创建好下一次的定时续期任务\",{\"1\":{\"3\":1}}],[\"明白aop的代理生成是由jdk或cglib代理实现\",{\"1\":{\"13\":1}}],[\"用其getroutedefinitions方法统一提供routedefinition\",{\"1\":{\"39\":1}}],[\"用于生成route\",{\"1\":{\"39\":1}}],[\"用于生成早期引用\",{\"1\":{\"27\":1}}],[\"用于获取对象的早期引用\",{\"1\":{\"34\":1}}],[\"用于获取advisor\",{\"1\":{\"12\":1}}],[\"用于提前暴露代理引用\",{\"1\":{\"31\":1}}],[\"用于存放完全初始化好的\",{\"1\":{\"27\":1}}],[\"用于后续事务处理的\",{\"1\":{\"23\":1}}],[\"用户可以根据情况在transactionsynchronizationmanager中注册事务前置和后置方法\",{\"1\":{\"23\":1}}],[\"用户未设置过期时间\",{\"1\":{\"3\":1}}],[\"用户设置了过期时间\",{\"1\":{\"3\":1}}],[\"从接口方法中可以知道\",{\"1\":{\"39\":1}}],[\"从注册中心获取服务实例\",{\"1\":{\"39\":1}}],[\"从注册a的bean开始\",{\"1\":{\"28\":1}}],[\"从配置文件中获取routedefinition\",{\"1\":{\"39\":1}}],[\"从路由装配的过程看看能否实现动态路由\",{\"1\":{\"39\":1}}],[\"从而获取早期引用对象\",{\"1\":{\"29\":1}}],[\"从第三个map中删除对应工厂对象\",{\"1\":{\"27\":1}}],[\"从第二个map中获取半成品map\",{\"1\":{\"27\":1}}],[\"从该缓存中取出的\",{\"1\":{\"27\":1}}],[\"从springboot2\",{\"1\":{\"25\":1}}],[\"从事务同步管理器中获取数据库连接资源\",{\"1\":{\"23\":1}}],[\"从数据池中获取数据库连接\",{\"1\":{\"23\":1}}],[\"从容器中获取bean再调用\",{\"1\":{\"21\":1}}],[\"从advisedsupport中获取所有advisor通知器\",{\"1\":{\"15\":1}}],[\"从proxyfactory的方法中似乎没有将advisor织入的方法\",{\"1\":{\"12\":1}}],[\"从这个解锁标识的超时时间的计算发现\",{\"1\":{\"5\":1}}],[\"这两个类拥有save和delete方法\",{\"1\":{\"39\":1}}],[\"这种静态方式的路由配置可能无法满足需求\",{\"1\":{\"39\":1}}],[\"这种情况就会出现循环依赖\",{\"1\":{\"25\":1}}],[\"这就是\",{\"1\":{\"29\":1}}],[\"这就保证了\",{\"1\":{\"23\":1}}],[\"这样就形成了一个循环调用\",{\"1\":{\"25\":1}}],[\"这里第二个查询在缓存map里查找是否有该属性类名的bean\",{\"1\":{\"26\":1}}],[\"这里生成的advisor是instantiationmodelawarepointcutadvisorimpl类\",{\"1\":{\"18\":1}}],[\"这里拿jdkdynamicaopproxy类的展示\",{\"1\":{\"12\":1}}],[\"这个创建前校验\",{\"1\":{\"28\":1}}],[\"这个field是属于哪个对象的\",{\"1\":{\"26\":1}}],[\"这个解锁标识的设置时间是redisson的redis客户端\",{\"1\":{\"5\":1}}],[\"这个问题的提出者\",{\"1\":{\"5\":1}}],[\"调用publishrefreshevent方法\",{\"1\":{\"39\":1}}],[\"调用\",{\"1\":{\"36\":1,\"39\":1}}],[\"调用dogetbean\",{\"1\":{\"28\":1}}],[\"调用工厂对象的getobject方法\",{\"1\":{\"27\":1}}],[\"调用数据库连接的手动提交和回滚\",{\"1\":{\"24\":1}}],[\"调用starttransaction\",{\"1\":{\"23\":1}}],[\"调用原方法\",{\"1\":{\"23\":1}}],[\"调用时机交给用户控制\",{\"1\":{\"16\":1}}],[\"调用abstractaspectjadvice的invokeadvicemethod方法\",{\"1\":{\"16\":1}}],[\"调用目标方法\",{\"1\":{\"16\":1}}],[\"调用getinterceptorsanddynamicinterceptionadvice\",{\"1\":{\"15\":1}}],[\"调用getproxy\",{\"1\":{\"12\":1}}],[\"调用了private\",{\"1\":{\"3\":1}}],[\"所以routepredicatehandlermapping拿到的就是cachingroutelocator类\",{\"1\":{\"39\":1}}],[\"所以在spring框架下\",{\"1\":{\"30\":1}}],[\"所以需要先保证dependson依赖的bean先初始化\",{\"1\":{\"28\":1}}],[\"所以可以在子线程调用开启事务的方法之前\",{\"1\":{\"24\":1}}],[\"所以如果加入父事务的子事务抛出了异常\",{\"1\":{\"23\":1}}],[\"所以当子事务方法\",{\"1\":{\"23\":1}}],[\"所以一个切面内的advice顺序按照around\",{\"1\":{\"18\":1}}],[\"所以aspect切面中的advice类生成后\",{\"1\":{\"18\":1}}],[\"所以使用finally\",{\"1\":{\"16\":1}}],[\"所以说springaop通过cglib和jdk两种动态代理方式实现\",{\"1\":{\"12\":1}}],[\"所有内容都是本人查阅资料后的个人理解\",{\"1\":{\"0\":1}}],[\"做了什么\",{\"1\":{\"12\":1}}],[\"该类还是一个监听器\",{\"1\":{\"39\":1}}],[\"该类是实现动态更新的关键\",{\"1\":{\"39\":1}}],[\"该类是用来生成route\",{\"1\":{\"39\":1}}],[\"该类的主要方法\",{\"1\":{\"12\":1}}],[\"该工厂对象通过lambda传入一个方法\",{\"1\":{\"29\":1}}],[\"该语句使得初始化时相同后置处理器不会再次生成产生代理对象\",{\"1\":{\"29\":1}}],[\"该方法就会异常\",{\"1\":{\"29\":1}}],[\"该方法就是用于在循环依赖发生后\",{\"1\":{\"29\":1}}],[\"该方法主要三大部分\",{\"1\":{\"29\":1}}],[\"该方法还有个重载方法\",{\"1\":{\"27\":1}}],[\"该方法会创建一个事务状态对象\",{\"1\":{\"23\":1}}],[\"该方法和tryacquireasync类似\",{\"1\":{\"4\":1}}],[\"该资源是通过threadlocal与线程绑定的\",{\"1\":{\"23\":1}}],[\"该对象拥有一个annotationawareordercomparator\",{\"1\":{\"19\":1}}],[\"织入器\",{\"0\":{\"12\":1}}],[\"定义\",{\"1\":{\"23\":1}}],[\"定义在哪个pointcut上执行哪个advice\",{\"1\":{\"11\":1}}],[\"定时任务\",{\"1\":{\"3\":1}}],[\"定时任务内容为\",{\"1\":{\"3\":1}}],[\"而使用\",{\"1\":{\"34\":1}}],[\"而普通aop代理在循环依赖的情况下\",{\"1\":{\"34\":1}}],[\"而asyncannotationbeanpostprocessor并不没有实现smartinstantiationawarebeanpostprocessor\",{\"1\":{\"34\":1}}],[\"而around的类型直接实现的methodinterceptor类\",{\"1\":{\"10\":1}}],[\"而b和c又依赖a的情况下\",{\"1\":{\"31\":1}}],[\"而是处理使用xml定义bean时定义的depends\",{\"1\":{\"28\":1}}],[\"而\",{\"1\":{\"25\":1,\"34\":1}}],[\"而获取的数据库连接资源绑定在线程中由transactionsynchronizationmanager帮忙管理\",{\"1\":{\"24\":1}}],[\"而原对象方法还是使用原对象来调用的\",{\"1\":{\"21\":1}}],[\"而不是代理对象\",{\"1\":{\"21\":1}}],[\"而我们在切面中定义advice时先按顺序是before\",{\"1\":{\"18\":1}}],[\"而解锁标识的设置和过期事件值\",{\"1\":{\"5\":1}}],[\"像methodbeforeadvice\",{\"1\":{\"10\":1}}],[\"每次执行都需要做匹配操作\",{\"1\":{\"9\":1}}],[\"每次续期任务执行后\",{\"1\":{\"3\":1}}],[\"动态匹配主是参数的匹配\",{\"1\":{\"9\":1}}],[\"常见的几个实现类jdkregexpmethodpointcut\",{\"1\":{\"9\":1}}],[\"相应的joinpoint\",{\"1\":{\"9\":1}}],[\"查看实现类\",{\"1\":{\"39\":1}}],[\"查看源码\",{\"1\":{\"3\":1}}],[\"查找匹配\",{\"1\":{\"9\":1}}],[\"客户端在最长重试时间内\",{\"1\":{\"5\":1}}],[\"客户端在解锁后的逻辑处理中会检查解锁任务的结果\",{\"1\":{\"5\":1}}],[\"那如何实现动态\",{\"1\":{\"39\":1}}],[\"那如何将切面织入目标对象生成对应的代理对象呢\",{\"1\":{\"12\":1}}],[\"那我们可以通过直接注入routedefinitionrepository类的实例来实现对路由配置的增加和删除\",{\"1\":{\"39\":1}}],[\"那么exposedobject\",{\"1\":{\"34\":1}}],[\"那么earlysingletonexposure为true\",{\"1\":{\"29\":1}}],[\"那么如果a对象依赖b和c\",{\"1\":{\"31\":1}}],[\"那么原方法调用完成后\",{\"1\":{\"23\":1}}],[\"那就需要从第三个map中获取工厂对象来获取半成品bean\",{\"1\":{\"27\":1}}],[\"那就false\",{\"1\":{\"4\":1}}],[\"那为什么异常被捕获事务没有失效\",{\"1\":{\"23\":1}}],[\"那父事务其实会正常进入提交的操作但是最后还是会回滚\",{\"1\":{\"23\":1}}],[\"那事务状态中isnewtransaction为true\",{\"1\":{\"23\":1}}],[\"那advisor的order哪来的\",{\"1\":{\"19\":1}}],[\"那aop代理对象执行方法时\",{\"1\":{\"13\":1}}],[\"那不同切面的advisor如何排序\",{\"1\":{\"19\":1}}],[\"那\",{\"1\":{\"5\":1}}],[\"正常返回null给客户端\",{\"1\":{\"5\":1}}],[\"就是使用proxyfactory创建的aop代理对象\",{\"1\":{\"36\":1}}],[\"就是查找目标对象是否有advisor\",{\"1\":{\"19\":1}}],[\"就进入if分组\",{\"1\":{\"29\":1}}],[\"就进入分支执行dosetrollbackonly\",{\"1\":{\"23\":1}}],[\"就通过后置处理器的getearlybeanreference\",{\"1\":{\"29\":1}}],[\"就调用addsingletonfactory\",{\"1\":{\"29\":1}}],[\"就谈不上事务了\",{\"1\":{\"24\":1}}],[\"就使用父类方法匹对\",{\"1\":{\"23\":1}}],[\"就能获取相应的拦截器链\",{\"1\":{\"16\":1}}],[\"就会事务失效\",{\"1\":{\"23\":1}}],[\"就会illegalmonitorstateexception异常\",{\"1\":{\"5\":1}}],[\"就会判断锁不存在了\",{\"1\":{\"5\":1}}],[\"就将其转换为数字返回\",{\"1\":{\"5\":1}}],[\"于是客户端再次发起解锁命令的执行\",{\"1\":{\"5\":1}}],[\"于是自己也尝试使用\",{\"1\":{\"0\":1}}],[\"也就达到了统一提供getroutedefinitions方法的目的\",{\"1\":{\"39\":1}}],[\"也就是能从routedefinitionrepository的实现类中\",{\"1\":{\"39\":1}}],[\"也就是多线程下获取的数据库连接都不一致了\",{\"1\":{\"24\":1}}],[\"也就是最终一个aop代理对象中的拦截器或者说通知器的顺序\",{\"1\":{\"19\":1}}],[\"也就是按照advisor的order进行排序的\",{\"1\":{\"19\":1}}],[\"也就是redis客户端如果存在服务端响应超时\",{\"1\":{\"5\":1}}],[\"也是一个routedefinitionlocator包装类\",{\"1\":{\"39\":1}}],[\"也表示解锁成功\",{\"1\":{\"5\":1}}],[\"最后注入b对象中属性中\",{\"1\":{\"29\":1}}],[\"最后返回bean\",{\"1\":{\"26\":1}}],[\"最后还是进行了回滚\",{\"1\":{\"23\":1}}],[\"最后都是调用拦截器的invoke方法\",{\"1\":{\"16\":1}}],[\"最后组成的集合\",{\"1\":{\"15\":1}}],[\"最后解锁\",{\"1\":{\"5\":1}}],[\"最终使用三级缓存中获得的引用\",{\"1\":{\"29\":1}}],[\"最终又是调用getbean\",{\"1\":{\"29\":1}}],[\"最终创建了一个bean的原始对象\",{\"1\":{\"29\":1}}],[\"最终导致调用栈内存溢出\",{\"1\":{\"25\":1}}],[\"最终会调用beanfactoryaspectjadvisorsbuilder的buildaspectjadvisors\",{\"1\":{\"18\":1}}],[\"最终通过tryacquireonceasync方法\",{\"1\":{\"4\":1}}],[\"最终释放订阅\",{\"1\":{\"3\":1}}],[\"执行getsingleton2\",{\"1\":{\"29\":1}}],[\"执行了哪些操作\",{\"1\":{\"28\":1}}],[\"执行到提交操作时\",{\"1\":{\"23\":1}}],[\"执行到内部方法时\",{\"1\":{\"22\":1}}],[\"执行另一创建事务状态对象的逻辑handleexistingtransaction\",{\"1\":{\"23\":1}}],[\"执行过程顺序为\",{\"1\":{\"16\":1}}],[\"执行父类abstractaspectjadvice的模板方法\",{\"1\":{\"16\":1}}],[\"执行时\",{\"1\":{\"16\":1}}],[\"执行\",{\"1\":{\"16\":1}}],[\"执行业务逻辑\",{\"1\":{\"5\":1}}],[\"执行一次timertask内容\",{\"1\":{\"3\":1}}],[\"他的操作也是正常尝试获取锁成功后\",{\"1\":{\"5\":1}}],[\"开发者没有给出解释\",{\"1\":{\"5\":1}}],[\"开启默认事务传播行为\",{\"1\":{\"24\":1}}],[\"开启事务\",{\"1\":{\"23\":1}}],[\"开启事务的具体处理由事务管理器的抽象类\",{\"1\":{\"23\":1}}],[\"开启事务并设置手动提交\",{\"1\":{\"23\":1}}],[\"开启异步续期\",{\"1\":{\"3\":1}}],[\"开启\",{\"1\":{\"3\":1}}],[\"抛出异常\",{\"1\":{\"22\":1,\"29\":1}}],[\"抛出了illegalmonitorstateexception\",{\"1\":{\"5\":1}}],[\"抛出timeoutexception\",{\"1\":{\"4\":1}}],[\"遇到的问题是\",{\"1\":{\"5\":1}}],[\"discoveryclientroutedefinitionlocator\",{\"1\":{\"39\":1}}],[\"datasource\",{\"1\":{\"24\":5}}],[\"datasourcetransactionmanager\",{\"1\":{\"23\":1}}],[\"docreatebean创建bean流程中\",{\"1\":{\"34\":1}}],[\"docreatebean\",{\"0\":{\"29\":1}}],[\"dogetbean一开始就使用getsingleton\",{\"1\":{\"28\":1}}],[\"dogetbean\",{\"0\":{\"28\":1}}],[\"dogettransaction\",{\"1\":{\"23\":1}}],[\"do\",{\"1\":{\"27\":1}}],[\"dobegin\",{\"1\":{\"23\":1}}],[\"does\",{\"1\":{\"5\":1}}],[\"dm\",{\"1\":{\"16\":3}}],[\"dynamic\",{\"1\":{\"16\":2}}],[\"dependson可以指定bean的创建和销毁顺序\",{\"1\":{\"28\":1}}],[\"dependson注解的依赖\",{\"1\":{\"28\":1}}],[\"dept1\",{\"1\":{\"24\":3}}],[\"deptservice\",{\"1\":{\"23\":1,\"24\":2}}],[\"dept\",{\"1\":{\"23\":5,\"24\":7,\"26\":3}}],[\"debug\",{\"1\":{\"27\":1}}],[\"debug会发现其中的getadvisormethods\",{\"1\":{\"18\":1}}],[\"destroy\",{\"1\":{\"27\":1}}],[\"destruction\",{\"1\":{\"27\":1}}],[\"defstatus\",{\"1\":{\"23\":1}}],[\"default\",{\"1\":{\"19\":2}}],[\"defaultadvisorchainfactory\",{\"1\":{\"15\":1}}],[\"defaultaopproxyfactory的createaopproxy\",{\"1\":{\"12\":1}}],[\"defaults\",{\"1\":{\"11\":1}}],[\"defaultpointcutadvisor\",{\"1\":{\"11\":7}}],[\"details\",{\"1\":{\"21\":1}}],[\"determined\",{\"1\":{\"5\":1}}],[\"demo\",{\"1\":{\"16\":4}}],[\"delete方法\",{\"1\":{\"39\":1}}],[\"del\",{\"1\":{\"5\":3}}],[\"和routedefinitionlocator的处理类似\",{\"1\":{\"39\":1}}],[\"和初次创建a对象一样就会走else分支\",{\"1\":{\"29\":1}}],[\"和上面流程一样\",{\"1\":{\"29\":1}}],[\"和triggerbeforecompletion\",{\"1\":{\"23\":1}}],[\"和拦截器集合\",{\"1\":{\"16\":1}}],[\"和\",{\"1\":{\"5\":1,\"23\":1}}],[\"和lock调用相同的方法\",{\"1\":{\"4\":1}}],[\"判断缓存map的key里面是否有该类名\",{\"1\":{\"26\":1}}],[\"判断是否为动态匹配\",{\"1\":{\"16\":1}}],[\"判断解锁标识\",{\"1\":{\"5\":1}}],[\"判断当前锁当前线程是否存在\",{\"1\":{\"5\":1}}],[\"通知类构造的拦截器顺序是around\",{\"1\":{\"18\":1}}],[\"通知类的排序\",{\"0\":{\"17\":1}}],[\"通知器\",{\"1\":{\"11\":1}}],[\"通知其他线程可以尝试获取锁\",{\"1\":{\"5\":1}}],[\"通过该类更新路由信息就可以实现动态路由\",{\"1\":{\"39\":1}}],[\"通过save和delete方法\",{\"1\":{\"39\":1}}],[\"通过源码分析\",{\"1\":{\"24\":1}}],[\"通过对事务属性中的事务传播行为判断\",{\"1\":{\"23\":1}}],[\"通过查看事务对象是否存在数据连接持有对象\",{\"1\":{\"23\":1}}],[\"通过查看key\",{\"1\":{\"3\":1}}],[\"通过递归调用proceed\",{\"1\":{\"16\":1}}],[\"通过构造器持有代理对象\",{\"1\":{\"16\":1}}],[\"通过构造器可以传入目标对象\",{\"1\":{\"12\":1}}],[\"通过适配器将advisor中的advice转换为methodinterceptor\",{\"1\":{\"15\":1}}],[\"通过上述内容\",{\"1\":{\"13\":1}}],[\"通过探寻createaopproxy\",{\"1\":{\"12\":1}}],[\"通过其父类org\",{\"1\":{\"12\":1}}],[\"通过匹对是否存在指定类型的注解进行匹配\",{\"1\":{\"9\":1}}],[\"通过匹配方法名进行匹配\",{\"1\":{\"9\":1}}],[\"通过正则表达式对方法名进行匹配\",{\"1\":{\"9\":1}}],[\"说明当前线程已经完全释放了锁\",{\"1\":{\"5\":1}}],[\"说明当前线程还有方法获取着当前锁\",{\"1\":{\"5\":1}}],[\"说明加锁成功\",{\"1\":{\"3\":1}}],[\"扣减一次重入次数\",{\"1\":{\"5\":1}}],[\"计算得到\",{\"1\":{\"5\":1}}],[\"由routedefinitionrepository继承\",{\"1\":{\"39\":1}}],[\"由于是新持有对象\",{\"1\":{\"23\":1}}],[\"由于时间碎片化\",{\"1\":{\"0\":1}}],[\"由事务管理器实现类实现\",{\"1\":{\"23\":1}}],[\"由具体的事务管理器实现类实现\",{\"1\":{\"23\":1}}],[\"由原对象调用的方法中使用this\",{\"1\":{\"21\":1}}],[\"由proceedingjoinpoint调用\",{\"1\":{\"16\":1}}],[\"由advisedsupport持有的advisorchainfactory属性\",{\"1\":{\"15\":1}}],[\"由\",{\"1\":{\"5\":1}}],[\"超时时间\",{\"1\":{\"5\":1}}],[\"404\",{\"1\":{\"40\":1}}],[\"4871的问题出现就能解释了\",{\"1\":{\"5\":1}}],[\"4871\",{\"1\":{\"5\":1}}],[\"4\",{\"1\":{\"5\":3,\"22\":1}}],[\"52423918\",{\"1\":{\"21\":1}}],[\"5\",{\"1\":{\"5\":5,\"22\":1}}],[\"~=\",{\"1\":{\"5\":2}}],[\"value存bean实例\",{\"1\":{\"26\":1}}],[\"val\",{\"1\":{\"5\":6}}],[\"v\",{\"1\":{\"5\":2}}],[\"void\",{\"1\":{\"3\":4,\"5\":1,\"11\":1,\"16\":10,\"23\":2,\"24\":2,\"26\":1}}],[\"底层解锁处理由redissonlock的unlockinnerasync方法实现\",{\"1\":{\"5\":1}}],[\"是实现动态路由的关键之一\",{\"1\":{\"39\":1}}],[\"是否为新事物等等信息\",{\"1\":{\"23\":1}}],[\"是否为新持有对象的标识\",{\"1\":{\"23\":1}}],[\"是否携带事务而进行的处理态度\",{\"1\":{\"22\":1}}],[\"是按照切面类的order来的\",{\"1\":{\"19\":1}}],[\"是调用目标原方法\",{\"1\":{\"16\":1}}],[\"是动态匹配\",{\"1\":{\"16\":1}}],[\"是redissonlock的父类redissonbaselock的方法\",{\"1\":{\"5\":1}}],[\"是由redissonlock类实现的方法\",{\"1\":{\"3\":1}}],[\"知道获取锁成功\",{\"1\":{\"4\":1}}],[\"知道产生中断或者获取到锁\",{\"1\":{\"3\":1}}],[\"持续获取锁\",{\"1\":{\"4\":1}}],[\"并没有实现postprocessbeforeinitialization\",{\"1\":{\"36\":1}}],[\"并不是指属性依赖注入的依赖初始化\",{\"1\":{\"28\":1}}],[\"并不会走提交\",{\"1\":{\"23\":1}}],[\"并将子线程的异常正常抛出\",{\"1\":{\"24\":1}}],[\"并将连接持有对象存入到事务对象中\",{\"1\":{\"23\":1}}],[\"并查看\",{\"1\":{\"4\":1}}],[\"并且能够从一二级缓存中获取早期引用\",{\"1\":{\"29\":1}}],[\"并且开启了循环依赖的配置\",{\"1\":{\"29\":1}}],[\"并且创建的实际上是instantiationmodelawarepointcutadvisorimpl类\",{\"1\":{\"19\":1}}],[\"并且jdkdynamicaopproxy和cglibaopproxy也会持有advisedsupport类属性\",{\"1\":{\"12\":1}}],[\"并且设置一下解锁标识和过期时间\",{\"1\":{\"5\":1}}],[\"并且结果是抛出指定异常\",{\"1\":{\"4\":1}}],[\"并且都是没有自定义过期时间的参数\",{\"1\":{\"4\":1}}],[\"取消订阅\",{\"1\":{\"4\":1}}],[\"否则false\",{\"1\":{\"4\":1}}],[\"阻塞时间就是剩余的等待时间\",{\"1\":{\"4\":1}}],[\"阻塞等待\",{\"1\":{\"3\":1}}],[\"阻塞等待解锁消息\",{\"1\":{\"3\":1,\"4\":1}}],[\"订阅解锁消息\",{\"1\":{\"4\":1}}],[\"订阅解锁消息的任务\",{\"1\":{\"3\":1}}],[\"<p>default\",{\"1\":{\"11\":1}}],[\"<p>\",{\"1\":{\"11\":1}}],[\"<p>advice\",{\"1\":{\"11\":1}}],[\"<\",{\"1\":{\"4\":1}}],[\"<=\",{\"1\":{\"4\":4}}],[\"<t>\",{\"1\":{\"3\":1,\"26\":1}}],[\"更新操作完成后\",{\"1\":{\"39\":1}}],[\"更新cache\",{\"1\":{\"39\":1}}],[\"更新存放在自己属性中的路路由信息\",{\"1\":{\"39\":1}}],[\"更新等待时间\",{\"1\":{\"4\":1}}],[\"更新internallockleasetime为用户设定时间\",{\"1\":{\"3\":1}}],[\"重新获取到的route\",{\"1\":{\"39\":1}}],[\"重新获取维护着的routedefinition信息\",{\"1\":{\"39\":1}}],[\"重试发送命令的默认最长时间间隔\",{\"1\":{\"5\":1}}],[\"重试中\",{\"1\":{\"4\":1}}],[\"重试时间超时\",{\"1\":{\"4\":1}}],[\"重试等待时间\",{\"1\":{\"4\":1}}],[\"重载方法\",{\"1\":{\"3\":1}}],[\"再执行其中的beforesingletoncreation\",{\"1\":{\"29\":1}}],[\"再执行after方法\",{\"1\":{\"16\":1}}],[\"再调用mi\",{\"1\":{\"16\":1}}],[\"再通过aopproxy的getproxy\",{\"1\":{\"12\":1}}],[\"再次更新重试等待时间\",{\"1\":{\"4\":1}}],[\"再次获取时间\",{\"1\":{\"4\":1}}],[\"再来看一下带参数的trylock\",{\"1\":{\"4\":1}}],[\"再继续\",{\"1\":{\"3\":1}}],[\"使用该事件发布订阅机制实现动态更新路由的大致步骤\",{\"1\":{\"39\":1}}],[\"使用该事件发布订阅机制就可以实现动态的更新cachingroutelocator中的route信息\",{\"1\":{\"39\":1}}],[\"使用了getsingleton2\",{\"1\":{\"28\":1}}],[\"使用反射得到实例化的bean\",{\"1\":{\"26\":1}}],[\"使用gettransaction模板方法\",{\"1\":{\"23\":1}}],[\"使用的ordercomparator的方法\",{\"1\":{\"19\":1}}],[\"使用的是子类aspectjawareadvisorautoproxycreator的sortadvisors\",{\"1\":{\"19\":1}}],[\"使用父类的sortadvisors\",{\"1\":{\"19\":1}}],[\"使用适配器模式生成methodinterceptor\",{\"1\":{\"15\":1}}],[\"使用持有的advisedsupport\",{\"1\":{\"15\":1}}],[\"使用\",{\"0\":{\"34\":1},\"1\":{\"4\":1,\"39\":2}}],[\"续期底层调用redissonbaselock的renewexpirationasync方法\",{\"1\":{\"3\":1}}],[\"续期时间值\",{\"1\":{\"3\":1}}],[\"达到不断续期效果\",{\"1\":{\"3\":1}}],[\"达到超时处理\",{\"1\":{\"3\":1}}],[\"ultimate\",{\"1\":{\"15\":1}}],[\"userservice\",{\"1\":{\"23\":1,\"24\":1}}],[\"user\",{\"1\":{\"23\":7,\"24\":7}}],[\"use\",{\"1\":{\"11\":1}}],[\"used\",{\"1\":{\"11\":1}}],[\"using\",{\"1\":{\"11\":1}}],[\"update\",{\"1\":{\"3\":1}}],[\"unbindresource\",{\"1\":{\"24\":2}}],[\"unlockinnerasync\",{\"1\":{\"5\":6}}],[\"unlockasync0\",{\"1\":{\"5\":3}}],[\"unlockasync\",{\"1\":{\"5\":3}}],[\"unlock\",{\"0\":{\"5\":1},\"1\":{\"5\":7}}],[\"unable\",{\"1\":{\"4\":1}}],[\"unsubscribe\",{\"1\":{\"3\":1,\"4\":2}}],[\"unit\",{\"1\":{\"3\":11,\"4\":14}}],[\"obtain\",{\"1\":{\"29\":1}}],[\"obj\",{\"1\":{\"26\":6}}],[\"objectfactory<\",{\"1\":{\"27\":2}}],[\"object>\",{\"1\":{\"26\":1,\"39\":1}}],[\"object\",{\"1\":{\"15\":1,\"16\":9,\"26\":1,\"27\":5,\"29\":8}}],[\"on\",{\"1\":{\"28\":1}}],[\"out\",{\"1\":{\"16\":7,\"24\":4,\"26\":2}}],[\"of\",{\"1\":{\"16\":1,\"27\":3,\"29\":1}}],[\"occur\",{\"1\":{\"5\":1}}],[\"override\",{\"1\":{\"3\":1,\"4\":3,\"5\":2,\"11\":2,\"15\":1,\"16\":1,\"19\":1,\"29\":1}}],[\"orderutils\",{\"1\":{\"19\":1}}],[\"ordered\",{\"1\":{\"19\":4}}],[\"ordercomparator的子类\",{\"1\":{\"19\":1}}],[\"order\",{\"1\":{\"15\":1}}],[\"org\",{\"1\":{\"15\":1}}],[\"or\",{\"1\":{\"3\":2,\"4\":1}}],[\"毫秒后\",{\"1\":{\"3\":1}}],[\"3次\",{\"1\":{\"5\":1}}],[\"3000ms\",{\"1\":{\"5\":1}}],[\"3\",{\"1\":{\"3\":2,\"5\":12,\"22\":1,\"39\":1}}],[\"3时间频率续期\",{\"1\":{\"3\":1}}],[\"返回null\",{\"1\":{\"28\":1}}],[\"返回nil\",{\"1\":{\"3\":1}}],[\"返回事务状态对象\",{\"1\":{\"23\":1}}],[\"返回一个事务对象\",{\"1\":{\"23\":1}}],[\"返回获取锁失败结果\",{\"1\":{\"4\":1}}],[\"返回true\",{\"1\":{\"4\":2}}],[\"返回锁的剩余过期时间\",{\"1\":{\"3\":1}}],[\"且\",{\"1\":{\"3\":1}}],[\"设置的是bean里面的属性\",{\"1\":{\"26\":1}}],[\"设置为了false\",{\"1\":{\"23\":1}}],[\"设置新持有对象状态为true\",{\"1\":{\"23\":1}}],[\"设置解锁标识这段逻辑是\",{\"1\":{\"5\":1}}],[\"设置一下解锁标识和过期时间\",{\"1\":{\"5\":1}}],[\"设置过期时间\",{\"1\":{\"3\":1}}],[\"设置定时任务\",{\"1\":{\"3\":2}}],[\"将route存入exchange\",{\"1\":{\"39\":1}}],[\"将routedefinition缓存在concurrenthashmap中\",{\"1\":{\"39\":1}}],[\"将工厂对象存进第三级缓存\",{\"1\":{\"29\":1}}],[\"将下面的方法称为getsingleton2\",{\"1\":{\"27\":1}}],[\"将实例化的bean和类名存入缓存map中\",{\"1\":{\"26\":1}}],[\"将主线程中获取到的数据库连接资源绑定到子线程上\",{\"1\":{\"24\":1}}],[\"将当前事务的状态\",{\"1\":{\"23\":1}}],[\"将this作为第三个参数传入\",{\"1\":{\"14\":1}}],[\"将锁删除\",{\"1\":{\"5\":1}}],[\"将锁续期一下\",{\"1\":{\"5\":1}}],[\"将value\",{\"1\":{\"5\":1}}],[\"将任务变为完成状态\",{\"1\":{\"4\":1}}],[\"将hash结构的value增1\",{\"1\":{\"3\":1}}],[\"将获取锁对象时的name参数作为keys传入\",{\"1\":{\"3\":1}}],[\"锁标识\",{\"1\":{\"5\":1}}],[\"锁重试时间的限制\",{\"1\":{\"4\":1}}],[\"锁存在\",{\"1\":{\"3\":1}}],[\"锁存在并且是当前线程的\",{\"1\":{\"3\":1}}],[\"锁如果不存在\",{\"1\":{\"3\":1}}],[\"锁过期时间\",{\"1\":{\"3\":1}}],[\"线程标识\",{\"1\":{\"3\":1,\"5\":1}}],[\"key存类名\",{\"1\":{\"26\":1}}],[\"key\",{\"1\":{\"3\":1,\"5\":3}}],[\"keys\",{\"1\":{\"3\":13,\"5\":16}}],[\"24\",{\"1\":{\"5\":1}}],[\"2\",{\"1\":{\"3\":6,\"5\":6,\"22\":1,\"29\":1,\"39\":1}}],[\"applypropertyvalues\",{\"1\":{\"29\":1}}],[\"appeared\",{\"1\":{\"27\":1}}],[\"able\",{\"1\":{\"29\":1}}],[\"abstractautowirecapablebeanfactory类中的方法\",{\"1\":{\"36\":1}}],[\"abstractautowirecapablebeanfactory类中的docreatebean方法\",{\"1\":{\"29\":1}}],[\"abstractbeanfactory的getbean\",{\"1\":{\"28\":1}}],[\"abstractplatformtransactionmanager\",{\"1\":{\"23\":1}}],[\"abstractgenericpointcutadvisor\",{\"1\":{\"11\":1}}],[\"adaptargumentsifnecessary\",{\"1\":{\"16\":1}}],[\"addsingletonfactory\",{\"1\":{\"29\":1}}],[\"addsingleton\",{\"1\":{\"27\":1}}],[\"addrelatedcause\",{\"1\":{\"27\":1}}],[\"addall\",{\"1\":{\"15\":3}}],[\"add\",{\"1\":{\"15\":2,\"19\":2}}],[\"advised\",{\"1\":{\"15\":1}}],[\"advisedsupport提供的\",{\"1\":{\"12\":1}}],[\"advisors\",{\"1\":{\"15\":4,\"19\":6}}],[\"advisoradapterregistry\",{\"1\":{\"15\":1}}],[\"advisor类有了\",{\"1\":{\"12\":1}}],[\"advisor\",{\"0\":{\"11\":1},\"1\":{\"15\":10,\"19\":3}}],[\"advicemethodcomparator是一个comparator\",{\"1\":{\"18\":1}}],[\"advicemethodcomparator\",{\"1\":{\"18\":1}}],[\"advice等内容\",{\"1\":{\"12\":1}}],[\"advice\",{\"0\":{\"10\":1},\"1\":{\"11\":14,\"16\":1}}],[\"access\",{\"1\":{\"29\":1}}],[\"actualclass\",{\"1\":{\"15\":6}}],[\"acquirefailed\",{\"1\":{\"4\":6}}],[\"acquireuninterruptibly\",{\"1\":{\"3\":1}}],[\"acquire\",{\"1\":{\"3\":1,\"4\":1}}],[\"acquiredfuture\",{\"1\":{\"4\":6}}],[\"acquired\",{\"1\":{\"3\":2,\"4\":6,\"5\":1}}],[\"a\",{\"1\":{\"11\":2,\"15\":2,\"16\":2,\"23\":3,\"24\":1,\"25\":2,\"27\":3,\"29\":2}}],[\"already\",{\"1\":{\"16\":1}}],[\"allowcircularreferences\",{\"1\":{\"29\":1}}],[\"allowed\",{\"1\":{\"27\":1}}],[\"allowearlyreference\",{\"1\":{\"27\":2}}],[\"allow\",{\"1\":{\"25\":1,\"29\":1}}],[\"allof\",{\"1\":{\"24\":1}}],[\"all\",{\"1\":{\"11\":1}}],[\"also\",{\"1\":{\"11\":1}}],[\"always\",{\"1\":{\"9\":1}}],[\"async的代理对象是在初始化阶段得到的\",{\"1\":{\"34\":1}}],[\"async的代理是通过asyncannotationbeanpostprocessor\",{\"1\":{\"34\":1}}],[\"async的类获取到的早期引用是原始对象\",{\"1\":{\"34\":1}}],[\"async的类的代理对象生成和aop代理对象生成使用的是不同的类的方法\",{\"1\":{\"34\":1}}],[\"async的循环依赖无法解决的关键\",{\"1\":{\"29\":1}}],[\"async\",{\"0\":{\"34\":1}}],[\"assert\",{\"1\":{\"27\":1}}],[\"aservice\",{\"1\":{\"25\":6}}],[\"aspectjprecedencecomparator类的compareto实际使用的annotationawareordercomparator的compareto\",{\"1\":{\"19\":1}}],[\"aspectjprecedencecomparator类对象\",{\"1\":{\"19\":1}}],[\"aspectjprecedencecomparator\",{\"1\":{\"19\":1}}],[\"aspectjaroundadvice的invoke\",{\"1\":{\"16\":1}}],[\"aspectjaroundadvice\",{\"1\":{\"10\":1}}],[\"aspectjafteradvice的inovke\",{\"1\":{\"16\":1}}],[\"aspectjafteradvice\",{\"1\":{\"10\":1}}],[\"aspectclass\",{\"1\":{\"18\":1}}],[\"aspect\",{\"1\":{\"16\":1}}],[\"as\",{\"1\":{\"11\":1,\"15\":1}}],[\"aslist\",{\"1\":{\"5\":1,\"15\":3}}],[\"annotationawareaspectjautoproxycreator\",{\"1\":{\"34\":1,\"36\":1}}],[\"annotationawareordercomparator并没重写compareto\",{\"1\":{\"19\":1}}],[\"annotationmatchingpointcut\",{\"1\":{\"9\":2}}],[\"animal\",{\"1\":{\"16\":2}}],[\"an\",{\"1\":{\"11\":1,\"16\":2}}],[\"and\",{\"1\":{\"4\":1,\"11\":1,\"16\":3}}],[\"aop代理中会调用transactioninterceptor类中的invoke方法\",{\"1\":{\"23\":1}}],[\"aop代理执行过程\",{\"0\":{\"13\":1}}],[\"aoputils\",{\"1\":{\"16\":1}}],[\"aopproxyutils\",{\"1\":{\"16\":1}}],[\"aopproxy的实现类有\",{\"1\":{\"12\":1}}],[\"aop切面在spring中的对象\",{\"1\":{\"11\":1}}],[\"aop切点在spring中的对象\",{\"1\":{\"9\":1}}],[\"aop通知在spring中的对象\",{\"1\":{\"10\":1}}],[\"aop中几个主要接口和类\",{\"0\":{\"8\":1}}],[\"aop\",{\"0\":{\"7\":1},\"1\":{\"12\":4,\"15\":1}}],[\"are\",{\"1\":{\"27\":1}}],[\"article\",{\"1\":{\"21\":1}}],[\"around\",{\"1\":{\"16\":8}}],[\"args\",{\"1\":{\"26\":1,\"29\":1}}],[\"arguments\",{\"1\":{\"16\":4}}],[\"argv\",{\"1\":{\"3\":10,\"5\":19}}],[\"arraylist<>\",{\"1\":{\"15\":1,\"19\":2,\"24\":1}}],[\"arrays\",{\"1\":{\"5\":1,\"15\":3}}],[\"attempt\",{\"1\":{\"5\":3}}],[\"aftersingletoncreation\",{\"1\":{\"27\":1}}],[\"afterthrowing顺序\",{\"1\":{\"19\":1}}],[\"afterthrowing\",{\"1\":{\"18\":1}}],[\"afterreturning\",{\"1\":{\"18\":1,\"19\":1}}],[\"afterreturningadvice\",{\"1\":{\"10\":1}}],[\"after\",{\"1\":{\"4\":1,\"16\":5,\"18\":1,\"19\":1}}],[\"html\",{\"1\":{\"34\":1}}],[\"https\",{\"1\":{\"21\":1,\"34\":1}}],[\"here\",{\"1\":{\"16\":1}}],[\"hexists\",{\"1\":{\"3\":3,\"5\":2}}],[\"h\",{\"1\":{\"14\":1}}],[\"hasinstantiationawarebeanpostprocessors\",{\"1\":{\"29\":1}}],[\"hasintroductions\",{\"1\":{\"15\":4}}],[\"has\",{\"1\":{\"27\":1}}],[\"hashmap<>\",{\"1\":{\"26\":1}}],[\"hashedwheeltimer的newtimeout\",{\"1\":{\"3\":1}}],[\"hasmatchingintroductions\",{\"1\":{\"15\":1}}],[\"have\",{\"1\":{\"15\":1,\"16\":2}}],[\"handle\",{\"1\":{\"5\":1}}],[\"handlenosync\",{\"1\":{\"3\":1,\"4\":1}}],[\"hincrby\",{\"1\":{\"3\":2,\"5\":2}}],[\"++this\",{\"1\":{\"16\":1}}],[\"+\",{\"1\":{\"3\":10,\"4\":3,\"5\":22,\"11\":5,\"16\":1,\"27\":3,\"29\":2}}],[\"决定\",{\"1\":{\"3\":1}}],[\"按过期时间的1\",{\"1\":{\"3\":1}}],[\"成功后\",{\"1\":{\"3\":1}}],[\"获取了\",{\"1\":{\"39\":1}}],[\"获取的\",{\"1\":{\"34\":2}}],[\"获取a对象\",{\"1\":{\"29\":1}}],[\"获取工厂对象\",{\"1\":{\"27\":1}}],[\"获取缓存bean的实现在defaultsingletonbeanregistry类的方法getsingleton\",{\"1\":{\"27\":1}}],[\"获取要创建的bean的类名\",{\"1\":{\"26\":1}}],[\"获取bean的需要注入的属性\",{\"1\":{\"29\":1}}],[\"获取bean里面的属性\",{\"1\":{\"26\":1}}],[\"获取bean\",{\"1\":{\"26\":1}}],[\"获取下一个拦截器\",{\"1\":{\"16\":1}}],[\"获取pointcut进行方法的匹配\",{\"1\":{\"15\":1}}],[\"获取目标方法的拦截器链\",{\"1\":{\"15\":1}}],[\"获取拦截器链\",{\"0\":{\"15\":1}}],[\"获取到对应的aopproxy后\",{\"1\":{\"12\":1}}],[\"获取到锁\",{\"1\":{\"4\":1}}],[\"获取最终的aop代理对象\",{\"1\":{\"12\":1}}],[\"获取锁\",{\"1\":{\"4\":1}}],[\"获取锁还是调用的和lock方法一样的trylockinnerasync方法\",{\"1\":{\"4\":1}}],[\"获取锁失败\",{\"1\":{\"3\":1}}],[\"获取锁底层使用的lua脚本\",{\"1\":{\"3\":1}}],[\"获取锁成功后\",{\"1\":{\"3\":1}}],[\"获取锁成功\",{\"1\":{\"3\":1}}],[\"获取为null\",{\"1\":{\"3\":1}}],[\"name\",{\"1\":{\"19\":3,\"27\":1}}],[\"namematchmethodpointcut\",{\"1\":{\"9\":2}}],[\"nested\",{\"1\":{\"22\":1}}],[\"net\",{\"1\":{\"21\":1}}],[\"next\",{\"1\":{\"16\":1}}],[\"need\",{\"1\":{\"15\":1}}],[\"never\",{\"1\":{\"9\":2,\"22\":1}}],[\"newsingleton\",{\"1\":{\"27\":3}}],[\"newinstance\",{\"1\":{\"26\":1}}],[\"newproxyinstance\",{\"1\":{\"12\":1,\"14\":1}}],[\"newtimeout\",{\"1\":{\"3\":1}}],[\"new\",{\"1\":{\"3\":3,\"4\":2,\"5\":6,\"15\":3,\"16\":1,\"19\":3,\"22\":1,\"23\":3,\"24\":4,\"25\":4,\"26\":1,\"27\":2}}],[\"nosuchmethodexception\",{\"1\":{\"26\":2}}],[\"normally\",{\"1\":{\"11\":1,\"15\":1}}],[\"node\",{\"1\":{\"5\":1}}],[\"notnull\",{\"1\":{\"27\":1}}],[\"not\",{\"1\":{\"5\":3,\"16\":1,\"22\":1,\"27\":3,\"40\":1}}],[\"nil\",{\"1\":{\"3\":2,\"5\":2}}],[\"nullbean\",{\"1\":{\"29\":1}}],[\"nullable\",{\"1\":{\"11\":1,\"15\":1,\"16\":3}}],[\"null\",{\"1\":{\"3\":9,\"4\":6,\"5\":3,\"9\":2,\"11\":1,\"15\":3,\"16\":5,\"19\":2,\"27\":10,\"29\":2}}],[\"默认关闭\",{\"1\":{\"29\":1}}],[\"默认关闭循环依赖\",{\"1\":{\"25\":1}}],[\"默认使用internallockleasetime\",{\"1\":{\"3\":1}}],[\"默认leasetime为\",{\"1\":{\"3\":1}}],[\">around\",{\"1\":{\"18\":1}}],[\">after顺序给出的\",{\"1\":{\"18\":1}}],[\">after\",{\"1\":{\"18\":2}}],[\">before\",{\"1\":{\"18\":2}}],[\">\",{\"1\":{\"3\":4,\"4\":5,\"5\":9,\"14\":1,\"15\":2,\"16\":2,\"19\":1,\"24\":4,\"26\":1,\"27\":3,\"29\":5}}],[\">=\",{\"1\":{\"3\":1,\"4\":1}}],[\"routelocator又是通过routedefinitionlocator获取routedefinition\",{\"1\":{\"39\":1}}],[\"routedefinitionroutelocatorroutelocator的实现类之一\",{\"1\":{\"39\":1}}],[\"routedefinitionlocator\",{\"1\":{\"39\":1}}],[\"routedefinitionlocator的实现类如下\",{\"1\":{\"39\":1}}],[\"routedefinitionlocator接口定义了获取路由定义信息的方法\",{\"1\":{\"39\":1}}],[\"rootbeandefinition\",{\"1\":{\"29\":2}}],[\"r\",{\"1\":{\"5\":2}}],[\"run\",{\"1\":{\"3\":1,\"11\":1}}],[\"rfuture<void>\",{\"1\":{\"5\":2}}],[\"rfuture<boolean>\",{\"1\":{\"4\":2,\"5\":3}}],[\"rfuture<t>\",{\"1\":{\"3\":1}}],[\"rfuture<long>\",{\"1\":{\"3\":2}}],[\"recordsuppressedexceptions\",{\"1\":{\"27\":4}}],[\"references\",{\"1\":{\"29\":2}}],[\"references=true\",{\"1\":{\"25\":1}}],[\"reference\",{\"1\":{\"27\":1,\"29\":2}}],[\"reflectivemethodinvocation\",{\"1\":{\"16\":2}}],[\"request\",{\"1\":{\"27\":1}}],[\"requestid\",{\"1\":{\"5\":3}}],[\"requires\",{\"1\":{\"22\":1}}],[\"required走最后一个创建事务状态过程\",{\"1\":{\"23\":1}}],[\"required\",{\"1\":{\"22\":1}}],[\"registry\",{\"1\":{\"15\":4}}],[\"read\",{\"1\":{\"5\":2}}],[\"releasing\",{\"1\":{\"5\":1}}],[\"remove\",{\"1\":{\"3\":1,\"27\":1,\"29\":2}}],[\"resolving\",{\"1\":{\"29\":2}}],[\"resolvereference\",{\"1\":{\"29\":1}}],[\"resolvevalueifnecessary\",{\"1\":{\"29\":1}}],[\"resolve\",{\"1\":{\"29\":1}}],[\"resolvedtargettype\",{\"1\":{\"29\":1}}],[\"resource\",{\"1\":{\"24\":3}}],[\"result\",{\"1\":{\"19\":3,\"24\":2}}],[\"reschedule\",{\"1\":{\"3\":1}}],[\"res\",{\"1\":{\"3\":2,\"4\":2,\"5\":3}}],[\"renewal\",{\"1\":{\"3\":3}}],[\"renewexpirationasync\",{\"1\":{\"3\":2}}],[\"renewexpiration\",{\"1\":{\"3\":2}}],[\"redisroutedefinitionrepository后者我们自定义的实现类\",{\"1\":{\"39\":1}}],[\"redisexecutor\",{\"1\":{\"5\":1}}],[\"redisexception\",{\"1\":{\"5\":1}}],[\"redis客户端重试次数\",{\"1\":{\"5\":1}}],[\"redis客户端重试时间间隔\",{\"1\":{\"5\":1}}],[\"redis客户端响应超时时间\",{\"1\":{\"5\":1}}],[\"redistimeoutexception\",{\"1\":{\"4\":1}}],[\"redis\",{\"0\":{\"42\":1},\"1\":{\"3\":12,\"5\":16}}],[\"redisstrictcommand<t>\",{\"1\":{\"3\":1}}],[\"redisson3\",{\"1\":{\"5\":1}}],[\"redissonlockentry\",{\"1\":{\"3\":1}}],[\"redisson分布锁实现\",{\"0\":{\"2\":1}}],[\"redisson\",{\"0\":{\"41\":1},\"1\":{\"1\":1}}],[\"rediscommands\",{\"1\":{\"3\":3,\"4\":2,\"5\":2}}],[\"return\",{\"1\":{\"3\":15,\"4\":12,\"5\":14,\"9\":4,\"11\":2,\"15\":1,\"16\":7,\"19\":5,\"24\":2,\"26\":2,\"27\":2,\"29\":2}}],[\"会做何处理\",{\"1\":{\"39\":1}}],[\"会优先使用改类\",{\"1\":{\"39\":1}}],[\"会比较初始化后的对象与原始对象是否为同一引用\",{\"1\":{\"34\":1}}],[\"会比较初始化后的对象和原始对象引用是否一致\",{\"1\":{\"29\":1}}],[\"会去获取缓存中是否已经有记录\",{\"1\":{\"29\":1}}],[\"会进行初始化\",{\"1\":{\"29\":1}}],[\"会抛出异常\",{\"1\":{\"28\":1}}],[\"会查看第三层缓存\",{\"1\":{\"28\":1}}],[\"会查询所有属于目标对象的通知器类\",{\"1\":{\"19\":1}}],[\"会通过第三级缓存生成早期引用存放在此\",{\"1\":{\"27\":1}}],[\"会判断当前异常是否是定义的异常\",{\"1\":{\"23\":1}}],[\"会根据事务传播行为\",{\"1\":{\"23\":1}}],[\"会根据设置的时间重新发送3次\",{\"1\":{\"5\":1}}],[\"会从数据池中获取连接\",{\"1\":{\"23\":1}}],[\"会转换为advisor类型\",{\"1\":{\"18\":1}}],[\"会将methodinterceptor和methodmatcher封装为interceptoranddynamicmethodmatcher对象\",{\"1\":{\"15\":1}}],[\"会有缓存\",{\"1\":{\"9\":1}}],[\"会默认传入internallockleasetime值为30000ms\",{\"1\":{\"3\":1}}],[\"会阻塞ttl的时间\",{\"1\":{\"3\":1}}],[\"尝试获取锁\",{\"1\":{\"3\":1}}],[\"mbd\",{\"1\":{\"29\":9}}],[\"mutiplythreadtranscationmanager\",{\"1\":{\"24\":2}}],[\"must\",{\"1\":{\"11\":1,\"27\":1}}],[\"mybatis在执行sql前会从transactionsynchronizationmanager中取获取数据库连接\",{\"1\":{\"24\":1}}],[\"mysql存储引警不支持事务\",{\"1\":{\"21\":1}}],[\"mi\",{\"1\":{\"16\":11}}],[\"milliseconds\",{\"1\":{\"3\":4,\"4\":4}}],[\"mm\",{\"1\":{\"15\":6}}],[\"metadata\",{\"1\":{\"39\":1}}],[\"methodinvocation\",{\"1\":{\"16\":4}}],[\"methodinterceptor\",{\"1\":{\"15\":2,\"16\":1}}],[\"methodbeforeadviceinterceptor的invoke\",{\"1\":{\"16\":1}}],[\"method\",{\"1\":{\"15\":6,\"16\":8,\"27\":1}}],[\"methods\",{\"1\":{\"11\":2}}],[\"methodmatcher分为静态匹配和动态匹配\",{\"1\":{\"9\":1}}],[\"methodmatcher\",{\"1\":{\"9\":3,\"15\":1,\"16\":1}}],[\"meantime\",{\"1\":{\"27\":1}}],[\"message\",{\"1\":{\"3\":1,\"4\":1,\"5\":1}}],[\"main\",{\"1\":{\"25\":1,\"26\":1}}],[\"mandatory\",{\"1\":{\"22\":1}}],[\"matching\",{\"1\":{\"16\":1}}],[\"matcher\",{\"1\":{\"16\":1}}],[\"matches\",{\"1\":{\"9\":1,\"11\":2,\"15\":4,\"16\":1}}],[\"match\",{\"1\":{\"15\":4,\"16\":1}}],[\"math\",{\"1\":{\"5\":1}}],[\"max\",{\"1\":{\"5\":1}}],[\"masterslaveserversconfig\",{\"1\":{\"5\":1}}],[\"map<string\",{\"1\":{\"26\":1,\"39\":1}}],[\"map\",{\"1\":{\"3\":3}}],[\"ms\",{\"1\":{\"4\":1}}],[\"0后加入的循环依赖的配置\",{\"1\":{\"29\":1}}],[\"0开始\",{\"1\":{\"25\":1}}],[\"0\",{\"1\":{\"3\":6,\"4\":7,\"5\":8,\"24\":1}}],[\"期间如果锁被释放\",{\"1\":{\"3\":1}}],[\"没有显示的调用proceed\",{\"1\":{\"16\":1}}],[\"没有设置过期时间\",{\"1\":{\"3\":1}}],[\"没有获取到锁\",{\"1\":{\"3\":1}}],[\"没完成抛出指定异常\",{\"1\":{\"3\":1}}],[\"fetch\",{\"1\":{\"39\":1}}],[\"feild对应的value是否存在\",{\"1\":{\"3\":1}}],[\"from\",{\"1\":{\"27\":1}}],[\"framework\",{\"1\":{\"12\":4,\"15\":1}}],[\"full\",{\"1\":{\"27\":2}}],[\"future2\",{\"1\":{\"24\":2}}],[\"future1\",{\"1\":{\"24\":2}}],[\"future\",{\"1\":{\"3\":6,\"5\":2}}],[\"factorybeaninstancecache\",{\"1\":{\"29\":1}}],[\"factory\",{\"1\":{\"27\":1}}],[\"failed\",{\"1\":{\"16\":1}}],[\"false\",{\"1\":{\"4\":7,\"5\":2,\"27\":1,\"29\":1}}],[\"found\",{\"1\":{\"16\":1,\"40\":1}}],[\"for\",{\"1\":{\"3\":1,\"4\":1,\"9\":2,\"15\":2,\"19\":2,\"26\":2,\"27\":2,\"29\":4}}],[\"ff\",{\"1\":{\"5\":2}}],[\"findbridgedmethod\",{\"1\":{\"16\":1}}],[\"final\",{\"1\":{\"5\":1}}],[\"finally\",{\"1\":{\"3\":1,\"4\":1,\"16\":1,\"27\":1}}],[\"first\",{\"1\":{\"15\":1}}],[\"fieldname\",{\"1\":{\"26\":3}}],[\"fieldtype\",{\"1\":{\"26\":3}}],[\"fields\",{\"1\":{\"26\":2}}],[\"field\",{\"1\":{\"3\":1,\"26\":6}}],[\"f\",{\"1\":{\"3\":2,\"4\":2,\"5\":2}}],[\"www\",{\"1\":{\"34\":1}}],[\"wrapifnecessary\",{\"1\":{\"29\":1,\"36\":1}}],[\"writeasync\",{\"1\":{\"5\":1}}],[\"was\",{\"1\":{\"16\":1}}],[\"waittime\",{\"1\":{\"3\":6,\"4\":14}}],[\"waiting\",{\"1\":{\"3\":1,\"4\":1}}],[\"within\",{\"1\":{\"27\":1}}],[\"without\",{\"1\":{\"27\":1}}],[\"with\",{\"1\":{\"16\":1,\"27\":1}}],[\"will\",{\"1\":{\"11\":2,\"16\":2}}],[\"we\",{\"1\":{\"15\":3,\"16\":2}}],[\"why\",{\"1\":{\"5\":1}}],[\"when\",{\"1\":{\"5\":1,\"11\":1,\"29\":1}}],[\"whencomplete\",{\"1\":{\"3\":1,\"4\":1,\"24\":2}}],[\"while\",{\"1\":{\"3\":1,\"4\":1,\"27\":1}}],[\"b对象注入a对象属性中\",{\"1\":{\"29\":1}}],[\"bp\",{\"1\":{\"29\":1}}],[\"bservice\",{\"1\":{\"25\":6}}],[\"bindresource\",{\"1\":{\"24\":2}}],[\"b\",{\"1\":{\"23\":8,\"25\":1,\"31\":1}}],[\"blog\",{\"1\":{\"21\":1}}],[\"bridgemethodresolver\",{\"1\":{\"16\":1}}],[\"break\",{\"1\":{\"3\":1}}],[\"but\",{\"1\":{\"11\":1,\"15\":1}}],[\"bean就为fasle\",{\"1\":{\"34\":1}}],[\"beantype\",{\"1\":{\"29\":3}}],[\"beanwrapper\",{\"1\":{\"29\":1}}],[\"bean的创建过程主要分为三部分\",{\"1\":{\"30\":1}}],[\"bean的初始化\",{\"1\":{\"29\":1}}],[\"bean的实例化\",{\"1\":{\"29\":1}}],[\"bean属性填充\",{\"1\":{\"29\":1}}],[\"beancreationexception\",{\"1\":{\"27\":1}}],[\"beancreationnotallowedexception\",{\"1\":{\"27\":1}}],[\"beanname\",{\"1\":{\"26\":4,\"27\":18,\"29\":13}}],[\"bean\",{\"1\":{\"25\":3,\"26\":3,\"27\":7,\"29\":13}}],[\"beanfactoryaware\",{\"1\":{\"29\":1}}],[\"beanfactory\",{\"1\":{\"19\":3,\"27\":1}}],[\"been\",{\"1\":{\"16\":2}}],[\"beforesingletoncreation\",{\"1\":{\"27\":1}}],[\"before\",{\"1\":{\"11\":1,\"16\":8,\"18\":1,\"19\":1}}],[\"be\",{\"1\":{\"5\":1,\"11\":3,\"27\":1,\"29\":1}}],[\"by\",{\"1\":{\"5\":4,\"29\":1}}],[\"boolean\",{\"1\":{\"3\":3,\"4\":4,\"5\":1,\"15\":2,\"27\":3,\"29\":1}}],[\"不然返回原始对象\",{\"1\":{\"29\":1}}],[\"不然就返回原始引用\",{\"1\":{\"29\":1}}],[\"不进入该判断分支\",{\"1\":{\"28\":1}}],[\"不存在时才会创建代理对象\",{\"1\":{\"29\":1}}],[\"不存在递归调用getbean\",{\"1\":{\"26\":1}}],[\"不存在类名\",{\"1\":{\"26\":1}}],[\"不存在返回null\",{\"1\":{\"5\":1}}],[\"不管外部方法是否有事务\",{\"1\":{\"22\":1}}],[\"不受外部事务影响\",{\"1\":{\"22\":1}}],[\"不用this调用本类中的方法\",{\"1\":{\"21\":1}}],[\"不是动态匹配\",{\"1\":{\"16\":1}}],[\"不是的当前线程的\",{\"1\":{\"3\":1}}],[\"不带参数的trylock\",{\"1\":{\"4\":1}}],[\"不断尝试获取锁\",{\"1\":{\"3\":1}}],[\"不可中断\",{\"1\":{\"3\":1}}],[\"even\",{\"1\":{\"29\":1}}],[\"evaluated\",{\"1\":{\"16\":2}}],[\"evaluate\",{\"1\":{\"16\":1}}],[\"evalwritesyncedasync\",{\"1\":{\"3\":2,\"5\":1}}],[\"eval\",{\"1\":{\"3\":3,\"4\":2,\"5\":1}}],[\"eligibleadvisors\",{\"1\":{\"19\":1}}],[\"else\",{\"1\":{\"3\":6,\"4\":3,\"5\":3,\"15\":4,\"16\":2,\"19\":1}}],[\"eagerly\",{\"1\":{\"29\":2}}],[\"eat\",{\"1\":{\"16\":6}}],[\"earlysingletonexposure为true\",{\"1\":{\"29\":1}}],[\"earlysingletonexposure\",{\"1\":{\"29\":2}}],[\"earlysingletonobjects\",{\"1\":{\"27\":4}}],[\"earlyproxyreferences\",{\"1\":{\"29\":3}}],[\"early\",{\"1\":{\"16\":1,\"27\":1,\"29\":1}}],[\"empty\",{\"1\":{\"11\":1}}],[\"error\",{\"1\":{\"3\":1,\"4\":1,\"5\":1}}],[\"ee\",{\"1\":{\"3\":3}}],[\"exposedobject\",{\"1\":{\"29\":3}}],[\"expiration\",{\"1\":{\"3\":4}}],[\"expirationentry\",{\"1\":{\"3\":2}}],[\"existing\",{\"1\":{\"27\":1}}],[\"exists\",{\"1\":{\"3\":2}}],[\"example\",{\"1\":{\"16\":4}}],[\"extends\",{\"1\":{\"11\":1}}],[\"execution\",{\"1\":{\"16\":4}}],[\"executionexception\",{\"1\":{\"4\":1}}],[\"executeasync\",{\"1\":{\"5\":1}}],[\"execute\",{\"1\":{\"4\":1,\"5\":1}}],[\"ex\",{\"1\":{\"4\":2,\"24\":2,\"27\":5}}],[\"exception\",{\"1\":{\"3\":1,\"27\":2}}],[\"enableaspectjautoproxy注解中通过\",{\"1\":{\"36\":1}}],[\"ent\",{\"1\":{\"3\":3}}],[\"entry\",{\"1\":{\"3\":8}}],[\"end\",{\"1\":{\"3\":3,\"5\":6}}],[\"e\",{\"1\":{\"3\":5,\"4\":4,\"5\":9}}],[\"可执行transactionsynchronizationmanager的绑定操作\",{\"1\":{\"23\":1}}],[\"可以做什么\",{\"1\":{\"39\":1}}],[\"可以直接使用\",{\"1\":{\"27\":1}}],[\"可以看到newtransaction\",{\"1\":{\"23\":1}}],[\"可以看到\",{\"1\":{\"23\":2}}],[\"可以看到不同情况会使用不同的动态代理方法\",{\"1\":{\"12\":1}}],[\"可以从述代码中看到\",{\"1\":{\"3\":1}}],[\"可能因为网络或者发送性能等原因没有在给定时间内得到服务端回复\",{\"1\":{\"5\":1}}],[\"可能存在着理解错误之处\",{\"1\":{\"0\":1}}],[\"可中断\",{\"1\":{\"3\":1}}],[\"postprocessbeforeinitialization\",{\"1\":{\"36\":1}}],[\"populatebean\",{\"1\":{\"29\":1,\"30\":1}}],[\"potential\",{\"1\":{\"29\":1}}],[\"pointcutadvisor\",{\"1\":{\"15\":6}}],[\"pointcut\",{\"0\":{\"9\":1},\"1\":{\"9\":5,\"11\":27,\"16\":1}}],[\"purpose\",{\"1\":{\"29\":1}}],[\"put\",{\"1\":{\"26\":1,\"27\":1,\"29\":2}}],[\"publish\",{\"1\":{\"5\":1}}],[\"public\",{\"1\":{\"3\":1,\"4\":3,\"5\":2,\"9\":1,\"11\":7,\"15\":1,\"16\":16,\"19\":1,\"23\":4,\"24\":2,\"25\":2,\"26\":2,\"27\":1,\"29\":1}}],[\"pubsub\",{\"1\":{\"3\":1}}],[\"pcadvisor\",{\"1\":{\"19\":2}}],[\"pjp\",{\"1\":{\"16\":2}}],[\"pmi\",{\"1\":{\"16\":3}}],[\"partialorder\",{\"1\":{\"19\":1}}],[\"partiallycomparableadvisorholder\",{\"1\":{\"19\":2}}],[\"partiallycomparableadvisors\",{\"1\":{\"19\":3}}],[\"part\",{\"1\":{\"16\":1}}],[\"param\",{\"1\":{\"11\":3}}],[\"parameters\",{\"1\":{\"4\":1}}],[\"px\",{\"1\":{\"5\":4}}],[\"precedence\",{\"1\":{\"19\":5}}],[\"preserve\",{\"1\":{\"15\":1}}],[\"primary注解\",{\"1\":{\"39\":2}}],[\"println\",{\"1\":{\"16\":7,\"24\":4,\"26\":2}}],[\"private\",{\"1\":{\"3\":3,\"4\":1,\"5\":1,\"11\":1,\"25\":2,\"26\":1}}],[\"propertiesroutedefinitionlocator\",{\"1\":{\"39\":1}}],[\"propertiesroutedefinitionlocator是routedefinitionlocator的一个实现类\",{\"1\":{\"39\":1}}],[\"proceedingjoinpoint\",{\"1\":{\"16\":3}}],[\"proceed\",{\"1\":{\"16\":8,\"27\":1}}],[\"process\",{\"1\":{\"15\":1}}],[\"problem\",{\"1\":{\"15\":1}}],[\"proxymethodinvocation\",{\"1\":{\"16\":4}}],[\"proxy\",{\"1\":{\"12\":1,\"14\":1,\"16\":3}}],[\"proxycreatorsupport的createaopproxy\",{\"1\":{\"12\":1}}],[\"proxyfactory类\",{\"1\":{\"12\":1}}],[\"protected\",{\"1\":{\"3\":1,\"5\":2,\"16\":1,\"19\":1,\"27\":1,\"29\":1}}],[\"pttl\",{\"1\":{\"3\":2}}],[\"pexpire\",{\"1\":{\"3\":3,\"5\":2}}],[\"smartinstantiationaware\",{\"1\":{\"29\":1}}],[\"smartinstantiationawarebeanpostprocessor\",{\"1\":{\"29\":1}}],[\"shared\",{\"1\":{\"27\":1}}],[\"synchronized\",{\"1\":{\"27\":2}}],[\"system\",{\"1\":{\"4\":8,\"16\":7,\"24\":4,\"26\":2}}],[\"save和delete方法来自routedefinitionwriter接口\",{\"1\":{\"39\":1}}],[\"save\",{\"1\":{\"23\":2,\"24\":3,\"39\":1}}],[\"suppressedexception\",{\"1\":{\"27\":2}}],[\"suppressedexceptions\",{\"1\":{\"27\":4}}],[\"supplyasync\",{\"1\":{\"24\":2}}],[\"supported\",{\"1\":{\"22\":1}}],[\"supports\",{\"1\":{\"22\":1}}],[\"super\",{\"1\":{\"19\":1}}],[\"subscriptionconnectionpoolsize\",{\"1\":{\"4\":1}}],[\"subscriptionsperconnection\",{\"1\":{\"4\":1}}],[\"subscription\",{\"1\":{\"4\":1}}],[\"subscribefuture\",{\"1\":{\"4\":7}}],[\"subscribe\",{\"1\":{\"3\":1,\"4\":1}}],[\"sorted\",{\"1\":{\"19\":3}}],[\"sortadvisors\",{\"1\":{\"19\":3}}],[\"sort\",{\"1\":{\"18\":1,\"19\":3}}],[\"so\",{\"1\":{\"16\":1}}],[\"somewhat\",{\"1\":{\"15\":1}}],[\"skip\",{\"1\":{\"16\":1}}],[\"since\",{\"1\":{\"27\":1}}],[\"singletons\",{\"1\":{\"27\":1,\"29\":1}}],[\"singletonscurrentlyindestruction\",{\"1\":{\"27\":1}}],[\"singletonfactory\",{\"1\":{\"27\":5}}],[\"singletonfactories\",{\"1\":{\"27\":3}}],[\"singletonobject\",{\"1\":{\"27\":18}}],[\"singletonobjects\",{\"1\":{\"27\":7}}],[\"singleton\",{\"1\":{\"27\":5}}],[\"singletonlist\",{\"1\":{\"3\":2}}],[\"size\",{\"1\":{\"16\":1,\"19\":2}}],[\"stuff\",{\"1\":{\"26\":3}}],[\"state\",{\"1\":{\"27\":1}}],[\"status\",{\"1\":{\"23\":3}}],[\"statically\",{\"1\":{\"16\":1}}],[\"static\",{\"1\":{\"16\":1,\"26\":3}}],[\"start\",{\"1\":{\"16\":1}}],[\"string\",{\"1\":{\"5\":3,\"11\":1,\"26\":3,\"27\":2,\"29\":3}}],[\"see\",{\"1\":{\"11\":1}}],[\"serializable\",{\"1\":{\"11\":1}}],[\"setaccessible\",{\"1\":{\"26\":1}}],[\"setadvice\",{\"1\":{\"11\":2}}],[\"setpassword\",{\"1\":{\"23\":1,\"24\":1}}],[\"setpointcut\",{\"1\":{\"11\":1}}],[\"setnickname\",{\"1\":{\"23\":1,\"24\":1}}],[\"setusername\",{\"1\":{\"23\":1,\"24\":1}}],[\"setdeptname\",{\"1\":{\"23\":1,\"24\":2}}],[\"setter\",{\"1\":{\"11\":1}}],[\"settimeout\",{\"1\":{\"3\":1}}],[\"set\",{\"1\":{\"5\":4,\"11\":2,\"26\":1}}],[\"specified\",{\"1\":{\"29\":1}}],[\"specify\",{\"1\":{\"11\":1}}],[\"specifying\",{\"1\":{\"11\":1}}],[\"spublish\",{\"1\":{\"5\":1}}],[\"springcloudgateway\",{\"0\":{\"38\":1}}],[\"springcloud\",{\"0\":{\"37\":1}}],[\"springcloud相关内容\",{\"1\":{\"1\":1}}],[\"spring处理循环依赖都是在实例化之后\",{\"1\":{\"33\":1}}],[\"spring处理事务的方式本质就是帮我们获取数据库连接\",{\"1\":{\"24\":1}}],[\"spring无法解决的循环依赖\",{\"0\":{\"32\":1}}],[\"spring使用三级缓存解决循环依赖问题\",{\"1\":{\"27\":1}}],[\"spring使用aop实现声明式事务\",{\"1\":{\"23\":1}}],[\"spring是如何解决循环依赖的\",{\"0\":{\"27\":1}}],[\"spring事务源码分析\",{\"0\":{\"23\":1}}],[\"spring声明式事务\",{\"0\":{\"20\":1}}],[\"springboot的aop代理生成流程\",{\"0\":{\"36\":1}}],[\"springboot\",{\"0\":{\"35\":1},\"1\":{\"29\":1}}],[\"springbootaopdemo\",{\"1\":{\"16\":4}}],[\"springboot相关内容\",{\"1\":{\"1\":1}}],[\"springframework\",{\"1\":{\"12\":4,\"15\":1}}],[\"spring提供了org\",{\"1\":{\"12\":1}}],[\"spring\",{\"0\":{\"6\":1,\"7\":1,\"8\":1,\"43\":1},\"1\":{\"16\":1,\"21\":1,\"30\":1}}],[\"spring相关内容\",{\"1\":{\"1\":1}}],[\"scheduleexpirationrenewal\",{\"1\":{\"3\":1,\"4\":1}}],[\"s\",{\"1\":{\"3\":2,\"16\":1}}],[\"c注入a时也是使用的二级缓存objectfactory对象创建a\",{\"1\":{\"31\":1}}],[\"c中注入的a会是两个对象\",{\"1\":{\"31\":1}}],[\"check\",{\"1\":{\"27\":1}}],[\"chain\",{\"1\":{\"16\":1}}],[\"chains\",{\"1\":{\"15\":1}}],[\"circular\",{\"1\":{\"25\":1,\"29\":3}}],[\"csdn\",{\"1\":{\"21\":1}}],[\"creation\",{\"1\":{\"27\":2}}],[\"creating\",{\"1\":{\"15\":1,\"27\":1}}],[\"createbeaninstance\",{\"1\":{\"29\":1,\"30\":1}}],[\"createtransactionifnecessary\",{\"1\":{\"23\":1}}],[\"created\",{\"1\":{\"15\":1}}],[\"create\",{\"1\":{\"11\":3}}],[\"classa\",{\"1\":{\"26\":2}}],[\"classes\",{\"1\":{\"26\":2}}],[\"class<t>\",{\"1\":{\"26\":1}}],[\"class<\",{\"1\":{\"14\":1,\"15\":2,\"16\":2,\"19\":1,\"26\":1,\"29\":1}}],[\"classloader\",{\"1\":{\"14\":1}}],[\"class\",{\"1\":{\"11\":1,\"16\":2,\"19\":1,\"23\":2,\"25\":2,\"26\":8,\"29\":1}}],[\"classfilter\",{\"1\":{\"9\":3}}],[\"ce\",{\"1\":{\"5\":6}}],[\"currentinterceptorindex\",{\"1\":{\"16\":2}}],[\"currenttime\",{\"1\":{\"4\":4}}],[\"currenttimemillis\",{\"1\":{\"4\":8}}],[\"currentthread\",{\"1\":{\"3\":1,\"4\":1,\"5\":1,\"24\":3}}],[\"current\",{\"1\":{\"4\":4,\"5\":3}}],[\"conditionalonmissingbean注解\",{\"1\":{\"39\":1}}],[\"conditionally\",{\"1\":{\"15\":1}}],[\"consistent\",{\"1\":{\"27\":1}}],[\"constructed\",{\"1\":{\"16\":1}}],[\"containskey\",{\"1\":{\"26\":2}}],[\"connectionholder\",{\"1\":{\"24\":2}}],[\"connectionholder为null\",{\"1\":{\"23\":1}}],[\"config\",{\"1\":{\"5\":4,\"15\":4}}],[\"code\",{\"1\":{\"9\":2,\"11\":3}}],[\"counter\",{\"1\":{\"5\":4}}],[\"collections\",{\"1\":{\"3\":2}}],[\"com\",{\"1\":{\"16\":4,\"34\":1}}],[\"compositeroutedefinitionlocator\",{\"1\":{\"39\":2}}],[\"component\",{\"1\":{\"16\":2}}],[\"comparator\",{\"1\":{\"19\":3}}],[\"completionexception\",{\"1\":{\"5\":4}}],[\"completionstage<void>\",{\"1\":{\"5\":1}}],[\"completionstage<boolean>\",{\"1\":{\"3\":2,\"4\":2,\"5\":2}}],[\"completionstage<long>\",{\"1\":{\"3\":2}}],[\"completeexceptionally\",{\"1\":{\"4\":2}}],[\"completablefuture\",{\"1\":{\"24\":3}}],[\"completablefuture<boolean>\",{\"1\":{\"24\":2}}],[\"completablefuture<redissonlockentry>\",{\"1\":{\"3\":1,\"4\":1}}],[\"completablefuturewrapper<>\",{\"1\":{\"3\":2,\"4\":1,\"5\":2}}],[\"commandbatchservice\",{\"1\":{\"5\":4}}],[\"commandasyncexecutor\",{\"1\":{\"5\":1}}],[\"command\",{\"1\":{\"3\":2}}],[\"commandexecutor\",{\"1\":{\"3\":2,\"4\":3,\"5\":2}}],[\"cachingroutelocator是装配形成route的最后一个环节\",{\"1\":{\"39\":1}}],[\"cachingroutelocator\",{\"1\":{\"39\":1}}],[\"cachingroutedefinitionlocator\",{\"1\":{\"39\":1}}],[\"caching\",{\"1\":{\"29\":1}}],[\"cachekey\",{\"1\":{\"29\":5}}],[\"cachemap\",{\"1\":{\"26\":6}}],[\"cache\",{\"1\":{\"15\":1,\"29\":1}}],[\"cat类的aop代理对象在执行相关方法时\",{\"1\":{\"18\":1}}],[\"cat\",{\"1\":{\"16\":6}}],[\"catch\",{\"1\":{\"3\":1,\"4\":2,\"5\":1,\"27\":2}}],[\"cause\",{\"1\":{\"5\":2}}],[\"canonical\",{\"1\":{\"9\":1}}],[\"cancelexpirationrenewal\",{\"1\":{\"3\":1,\"5\":1}}],[\"can\",{\"1\":{\"3\":1}}],[\"call\",{\"1\":{\"3\":12,\"5\":16}}],[\"结束方法\",{\"1\":{\"3\":1}}],[\"import导入aspectjautoproxyregistrar类\",{\"1\":{\"36\":1}}],[\"implicitly\",{\"1\":{\"27\":1}}],[\"implementation\",{\"1\":{\"27\":1}}],[\"implements\",{\"1\":{\"11\":1,\"16\":1}}],[\"illegalaccessexception\",{\"1\":{\"26\":2}}],[\"illegalstateexception\",{\"1\":{\"16\":1,\"27\":1}}],[\"illegalmonitorstateexception\",{\"1\":{\"5\":5}}],[\"ia\",{\"1\":{\"15\":2}}],[\"it\",{\"1\":{\"15\":1,\"16\":2,\"27\":1}}],[\"itself\",{\"1\":{\"3\":1}}],[\"issynthetic\",{\"1\":{\"29\":1}}],[\"issingletoncurrentlyincreation\",{\"1\":{\"27\":1,\"29\":1}}],[\"issingleton\",{\"1\":{\"19\":1,\"29\":2}}],[\"istraceenabled\",{\"1\":{\"29\":1}}],[\"isdebugenabled\",{\"1\":{\"27\":1}}],[\"isglobalrollbackonly\",{\"1\":{\"23\":1}}],[\"isexistingtransaction\",{\"1\":{\"23\":1}}],[\"isexistingtransaction判断当前是否已存在事务\",{\"1\":{\"23\":1}}],[\"isassignablefrom\",{\"1\":{\"19\":1}}],[\"isnewtransaction\",{\"1\":{\"23\":1}}],[\"isn\",{\"1\":{\"15\":1}}],[\"isruntime\",{\"1\":{\"15\":1}}],[\"isprefiltered\",{\"1\":{\"15\":2}}],[\"is\",{\"1\":{\"5\":1,\"11\":1,\"15\":1,\"16\":1}}],[\"id\",{\"1\":{\"5\":6}}],[\"inmemoryroutedefinitionrepository\",{\"1\":{\"39\":1}}],[\"inmemoryroutedefinitionrepository使用了\",{\"1\":{\"39\":1}}],[\"inmemoryroutedefinitionrepository和redisroutedefinitionrepository\",{\"1\":{\"39\":1}}],[\"initializebean\",{\"1\":{\"30\":1}}],[\"indicates\",{\"1\":{\"27\":1}}],[\"index\",{\"1\":{\"16\":1}}],[\"instantiate\",{\"1\":{\"29\":1}}],[\"instantiationexception\",{\"1\":{\"26\":2}}],[\"instantiationmodelawarepointcutadvisorimpl的getorder\",{\"1\":{\"19\":1}}],[\"instantiationmodelawarepointcutadvisorimpl类在为目标对象创建代理对象时\",{\"1\":{\"18\":1}}],[\"instancewrapper\",{\"1\":{\"29\":7}}],[\"instanceof\",{\"1\":{\"5\":4,\"15\":3,\"16\":2}}],[\"instance\",{\"1\":{\"3\":2,\"5\":2,\"9\":2,\"15\":1,\"27\":2}}],[\"invocationtargetexception\",{\"1\":{\"26\":2}}],[\"invocationhandler\",{\"1\":{\"14\":1}}],[\"invokeadvicemethod\",{\"1\":{\"16\":2}}],[\"invoke\",{\"1\":{\"16\":7}}],[\"invokejoinpoint\",{\"1\":{\"16\":1}}],[\"invokejoinpointusingreflection\",{\"1\":{\"16\":1}}],[\"increment\",{\"1\":{\"16\":1}}],[\"increase\",{\"1\":{\"4\":1}}],[\"in\",{\"1\":{\"15\":2,\"16\":1,\"27\":3}}],[\"introductionadvisor\",{\"1\":{\"15\":3}}],[\"introductionawaremethodmatcher\",{\"1\":{\"15\":2}}],[\"introductions\",{\"1\":{\"15\":1}}],[\"int\",{\"1\":{\"5\":3,\"19\":1,\"24\":1}}],[\"interceptororinterceptionadvice\",{\"1\":{\"16\":4}}],[\"interceptoranddynamicmethodmatcher\",{\"1\":{\"15\":1,\"16\":3}}],[\"interceptor\",{\"1\":{\"15\":4,\"16\":3}}],[\"interceptorsanddynamicmethodmatchers\",{\"1\":{\"16\":5}}],[\"interceptors\",{\"1\":{\"15\":7}}],[\"interceptorlist\",{\"1\":{\"15\":6}}],[\"interfaces\",{\"1\":{\"14\":1,\"29\":1}}],[\"interface\",{\"1\":{\"9\":1,\"16\":1}}],[\"internallockleasetime\",{\"1\":{\"3\":6,\"4\":2,\"5\":1}}],[\"interruptedexception\",{\"1\":{\"3\":2,\"4\":1}}],[\"interruptibly\",{\"1\":{\"3\":5}}],[\"if条件成立\",{\"1\":{\"4\":1}}],[\"if\",{\"1\":{\"3\":17,\"4\":12,\"5\":12,\"15\":8,\"16\":4,\"19\":3,\"26\":1,\"27\":14,\"29\":6}}],[\"130806813\",{\"1\":{\"21\":1}}],[\"1500ms\",{\"1\":{\"5\":1}}],[\"1\",{\"1\":{\"3\":26,\"4\":2,\"5\":21,\"16\":2,\"22\":1,\"24\":1,\"39\":1}}],[\"==\",{\"1\":{\"3\":11,\"4\":3,\"5\":3,\"15\":1,\"16\":1,\"26\":2,\"27\":7,\"29\":1,\"34\":1}}],[\"=\",{\"1\":{\"3\":18,\"4\":18,\"5\":16,\"9\":1,\"11\":4,\"15\":15,\"16\":13,\"19\":7,\"23\":3,\"24\":8,\"25\":2,\"26\":7,\"27\":15,\"29\":11}}],[\"typically\",{\"1\":{\"29\":1}}],[\"type\",{\"1\":{\"19\":4}}],[\"test\",{\"1\":{\"24\":3}}],[\"target\",{\"1\":{\"16\":3}}],[\"targetclass\",{\"1\":{\"15\":3,\"16\":7}}],[\"targeting\",{\"1\":{\"11\":2}}],[\"tasks\",{\"1\":{\"24\":1}}],[\"task\",{\"1\":{\"3\":2}}],[\"tolowercase\",{\"1\":{\"26\":2}}],[\"tostring\",{\"1\":{\"11\":1}}],[\"tonumber\",{\"1\":{\"5\":2}}],[\"to\",{\"1\":{\"4\":2,\"5\":4,\"11\":3,\"15\":2,\"16\":1,\"29\":4}}],[\"tomillis\",{\"1\":{\"3\":2,\"4\":2}}],[\"t\",{\"1\":{\"3\":1,\"15\":1,\"26\":3}}],[\"that\",{\"1\":{\"9\":1,\"11\":1,\"27\":1}}],[\"this指的的是对象本身\",{\"1\":{\"21\":1}}],[\"this\",{\"1\":{\"5\":1,\"9\":2,\"11\":4,\"15\":1,\"16\":19,\"19\":6,\"27\":17,\"29\":5}}],[\"the\",{\"1\":{\"5\":2,\"9\":4,\"11\":6,\"15\":2,\"16\":3,\"27\":3,\"29\":3}}],[\"then\",{\"1\":{\"3\":3,\"5\":6}}],[\"thenapply\",{\"1\":{\"3\":1,\"4\":1,\"5\":1}}],[\"throwable\",{\"1\":{\"16\":6}}],[\"throw\",{\"1\":{\"3\":1,\"5\":5,\"16\":1,\"27\":3}}],[\"throwsadvice\",{\"1\":{\"10\":1}}],[\"throws\",{\"1\":{\"3\":2,\"4\":1,\"16\":6,\"26\":2}}],[\"thread异常\",{\"1\":{\"5\":1}}],[\"thread\",{\"1\":{\"3\":1,\"4\":1,\"5\":4,\"24\":3}}],[\"threadid\",{\"1\":{\"3\":19,\"4\":19,\"5\":12}}],[\"trace\",{\"1\":{\"29\":1}}],[\"transactionsynchronizationmanager\",{\"1\":{\"24\":6}}],[\"transactionsynchronizationmanager中并不存在资源\",{\"1\":{\"23\":1}}],[\"transactionsynchronizationmanager保存着当前线程事务中的事务资源和一些事务信息\",{\"1\":{\"23\":1}}],[\"transactional\",{\"1\":{\"23\":2,\"24\":2}}],[\"triggered\",{\"1\":{\"29\":1}}],[\"tricky\",{\"1\":{\"15\":1}}],[\"truepointcut\",{\"1\":{\"9\":1}}],[\"true\",{\"1\":{\"3\":1,\"4\":3,\"9\":1,\"11\":6,\"24\":1,\"26\":1,\"27\":1}}],[\"trylockasync\",{\"1\":{\"4\":2}}],[\"trylock\",{\"0\":{\"4\":1},\"1\":{\"4\":3}}],[\"trylockinnerasync\",{\"1\":{\"3\":3,\"4\":2}}],[\"try\",{\"1\":{\"3\":2,\"4\":3,\"5\":1,\"16\":1,\"27\":1}}],[\"tryacquireonceasync\",{\"1\":{\"4\":2}}],[\"tryacquireasync\",{\"1\":{\"3\":1}}],[\"tryacquireasync0\",{\"1\":{\"3\":1}}],[\"tryacquire\",{\"1\":{\"3\":5,\"4\":4}}],[\"time\",{\"1\":{\"4\":13}}],[\"timertask\",{\"1\":{\"3\":1}}],[\"timeoutexception\",{\"1\":{\"4\":1}}],[\"timeout\",{\"1\":{\"3\":4,\"5\":7}}],[\"timeunit\",{\"1\":{\"3\":10,\"4\":7}}],[\"ttlremaining\",{\"1\":{\"3\":3}}],[\"ttlremainingfuture\",{\"1\":{\"3\":6}}],[\"ttl\",{\"1\":{\"3\":7,\"4\":7}}],[\"lambda传入第二个工厂的getobject\",{\"1\":{\"28\":1}}],[\"lazygetproceedingjoinpoint\",{\"1\":{\"16\":1}}],[\"like\",{\"1\":{\"29\":1}}],[\"lifecycle\",{\"1\":{\"29\":1}}],[\"linkedhashset<>\",{\"1\":{\"27\":1}}],[\"list<supplier>\",{\"1\":{\"24\":1}}],[\"list<partiallycomparableadvisorholder>\",{\"1\":{\"19\":2}}],[\"list<advisor>\",{\"1\":{\"19\":3}}],[\"list<object>\",{\"1\":{\"15\":2,\"16\":1}}],[\"list\",{\"1\":{\"15\":1}}],[\"length\",{\"1\":{\"15\":1}}],[\"leasetime\",{\"1\":{\"3\":13,\"4\":9}}],[\"lua执行结果\",{\"1\":{\"3\":1}}],[\"lowest\",{\"1\":{\"19\":2}}],[\"loader\",{\"1\":{\"14\":1}}],[\"local\",{\"1\":{\"5\":4}}],[\"lockpubsub\",{\"1\":{\"5\":1}}],[\"locked\",{\"1\":{\"5\":3}}],[\"lock\",{\"0\":{\"3\":1},\"1\":{\"3\":6,\"4\":4,\"5\":5,\"27\":2}}],[\"logger\",{\"1\":{\"4\":1,\"27\":2,\"29\":2}}],[\"log\",{\"1\":{\"3\":1}}],[\"longcodec\",{\"1\":{\"3\":2,\"5\":2}}],[\"long\",{\"1\":{\"3\":20,\"4\":13,\"5\":6}}],[\"源码分析之前\",{\"1\":{\"23\":1}}],[\"源码分析\",{\"0\":{\"3\":1,\"4\":1,\"5\":1}}],[\"本站内容\",{\"0\":{\"1\":1}}],[\"空余时间将本地笔记慢慢整理至此\",{\"1\":{\"0\":1}}],[\"网上有许多知识分享网站使用vuepress构建\",{\"1\":{\"0\":1}}],[\"笔记的内容混杂在多个本地文档中\",{\"1\":{\"0\":1}}],[\"导读\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
