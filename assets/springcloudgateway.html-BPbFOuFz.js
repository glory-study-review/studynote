import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as e,d as i}from"./app-BhKC0Yx3.js";const n="/studynote/assets/image-20240521215821590-C9loT9bJ.png",a="/studynote/assets/image-20240521220458288-DVzy7ags.png",p="/studynote/assets/image-20240521221036129-Btf25tZU.png",s="/studynote/assets/image-20240521221457610-C8odALrE.png",r="/studynote/assets/image-20240522092032082-BOoCf3QQ.png",c="/studynote/assets/image-20240522094535304-BMPv5rTr.png",d="/studynote/assets/image-20240522105627275-BEBoNJqO.png",l="/studynote/assets/image-20240522105912036-DVwjpoyx.png",g="/studynote/assets/image-20240522105935293-Ck7o_VOJ.png",u="/studynote/assets/image-20240522095633479-DW7R-GCG.png",m="/studynote/assets/image-20240522100533052-UHlymBdQ.png",y="/studynote/assets/image-20240522100853617-BiiCdEct.png",R="/studynote/assets/image-20240522103717209-DxrAh-lI.png",f="/studynote/assets/image-20240522103610162-Cpt2a-7w.png",_="/studynote/assets/image-20240522104333006-C1cB4Jzc.png",D="/studynote/assets/image-20240522143105741-Cag94KWl.png",h="/studynote/assets/image-20240522110520303-DWft_ZxC.png",C="/studynote/assets/image-20240522110545360-D3cGDRay.png",L="/studynote/assets/image-20240522142821774-BNc1vJmd.png",z="/studynote/assets/image-20240522143640416-DAR7ETuG.png",w="/studynote/assets/image-20240522154342117-Dy5QJ_xw.png",G="/studynote/assets/image-20240522154417538-D3DjD_Uv.png",v="/studynote/assets/image-20240522154439193-CfT6CxD3.png",x={},P=i('<h1 id="springcloudgateway" tabindex="-1"><a class="header-anchor" href="#springcloudgateway"><span>SpringCloudGateway</span></a></h1><h2 id="路由装配过程" tabindex="-1"><a class="header-anchor" href="#路由装配过程"><span>路由装配过程</span></a></h2><blockquote><p>路由配置主要使用yml配置文件和编码两种形式，在实际使用中，这种静态方式的路由配置可能无法满足需求，需要实现动态路由；</p><p>从路由装配的过程看看能否实现动态路由</p></blockquote><p>静态路由的配置对象<code>RouteDefinition</code></p><p><img src="'+n+'" alt="" loading="lazy"></p><p>项目启动，加载<code>GatewayAutoConfiguration</code>时，注册一个<code>PropertiesRouteDefinitionLocator</code>类将网关配置文件信息加载到内存中</p><p><code>PropertiesRouteDefinitionLocator</code>是<code>RouteDefinitionLocator</code>的一个实现类;<code>RouteDefinitionLocator</code>接口定义了获取路由定义信息的方法</p><p><img src="'+a+'" alt="" loading="lazy"></p><p><img src="'+p+'" alt="" loading="lazy"></p><p><img src="'+s+'" alt="" loading="lazy"></p><p><code>RouteDefinitionLocator</code>的实现类如下：</p><p><img src="'+r+'" alt="" loading="lazy"></p><ul><li><p><code>CachingRouteDefinitionLocator</code> 一个RouteDefinitionLocator包装类，将RouteDefinition缓存在ConcurrentHashMap中</p></li><li><p><code>PropertiesRouteDefinitionLocator</code> 如上所述，从配置文件中获取RouteDefinition</p></li><li><p><code>DiscoveryClientRouteDefinitionLocator</code> 从注册中心获取服务实例，构造RouteDefinition</p></li><li><p><code>InMemoryRouteDefinitionRepository</code>和<code>RedisRouteDefinitionRepository</code> 都是间接实现RouteDefinitionLocator，这两个类拥有save和delete方法，更新存放在自己属性中的路路由信息，是实现动态路由的关键之一</p></li><li><p><code>CompositeRouteDefinitionLocator</code> 也是一个RouteDefinitionLocator包装类，组合所有RouteDefinitionLocator，用其getRouteDefinitions方法统一提供RouteDefinition</p></li></ul><p>接下去看配置类的加载内容：</p><p><img src="'+c+'" alt="" loading="lazy"></p><p>InMemoryRouteDefinitionRepository使用了@ConditionalOnMissingBean注解，那我们可以通过直接注入RouteDefinitionRepository类的实例来实现对路由配置的增加和删除</p><p>CompositeRouteDefinitionLocator 使用@Primary注解，在其他需要注入RouteDefinitionLocator类的地方，会优先使用改类，也就达到了统一提供getRouteDefinitions方法的目的</p><p>来看一下<code>InMemoryRouteDefinitionRepository</code>类 可以做什么</p><p><img src="'+d+'" alt="" loading="lazy"></p><p>通过save和delete方法，维护保存在routes属性中的RouteDefinition信息</p><p>save和delete方法来自<code>RouteDefinitionWriter</code>接口，由RouteDefinitionRepository继承</p><p><img src="'+l+'" alt="" loading="lazy"></p><p><img src="'+g+'" alt="" loading="lazy"></p><p>现在如何对路由配置进行增加删除的入口已经找到，那如何实现动态，继续查找配置</p><p><img src="'+u+'" alt="" loading="lazy"></p><p><code>RouteDefinitionRouteLocator</code> <code>RouteLocator</code>的实现类之一</p><p>从接口方法中可以知道，该类是用来生成Route，查看实现类</p><p><img src="'+m+'" alt="" loading="lazy"></p><p>来看一下具体做了啥</p><p><img src="'+y+'" alt="" loading="lazy"></p><p><img src="'+R+'" alt="" loading="lazy"></p><p>获取了 路由定义定位器（RouteDefinitionLocator），过滤器工厂和断言工厂，用于生成Route；</p><p>继续查看配置类：</p><p>注册了<code>CachingRouteLocator</code> 一个RouteLocator的包装类，和RouteDefinitionLocator的处理类似，统一提供Routes，该类是实现动态更新的关键</p><p><img src="'+f+'" alt="" loading="lazy"></p><p>看一下具体内容：</p><p><img src="'+_+'" alt="" loading="lazy"></p><p>该类还是一个监听器，实现了ApplicationListener，监听RefreshRoutesEvent事件</p><p>监听到事件后，会做何处理：</p><p><img src="'+D+'" alt="" loading="lazy"></p><p><img src="'+h+'" alt="" loading="lazy"></p><p><img src="'+C+'" alt="" loading="lazy"></p><p>监听到事件后，调用 fetch()或fetch(Map&lt;String, Object&gt; metadata)方法，方法内部使用<code>RouteLocator</code>重新获取Route，RouteLocator又是通过<code>RouteDefinitionLocator</code>获取RouteDefinition，也就是能从<code>RouteDefinitionRepository</code>的实现类中（InMemoryRouteDefinitionRepository、RedisRouteDefinitionRepository后者我们自定义的实现类）重新获取维护着的RouteDefinition信息</p><p>重新获取到的Route，调用publishRefreshEvent方法，更新cache</p><p><img src="'+L+'" alt="" loading="lazy"></p><p><img src="'+z+'" alt="" loading="lazy"></p><p>至此，使用该事件发布订阅机制就可以实现动态的更新CachingRouteLocator中的Route信息</p><p>Gateway中通过RoutePredicateHandlerMapping类，在其中由属性RouteLocator获取Route的断言遍历匹配exchange，将route存入exchange，然后交给后续的FilteringWebHandler，匹配相应的过滤器执行相应内容；</p><p><img src="'+w+'" alt="" loading="lazy"></p><p><img src="'+G+'" alt="" loading="lazy"></p><p><img src="'+v+'" alt="" loading="lazy"></p><p>CachingRouteLocator 使用@Primary注解，所以RoutePredicateHandlerMapping拿到的就是CachingRouteLocator类，CachingRouteLocator是装配形成Route的最后一个环节，通过该类更新路由信息就可以实现动态路由</p><p>使用该事件发布订阅机制实现动态更新路由的大致步骤：</p><p>1、自定义实现RouteDefinitionRepository接口</p><p>2、根据需求使用数据库、缓存等，实现getRouteDefinitions、save、delete方法</p><p>3、更新操作完成后，发布一个RefreshRoutesEvent事件</p>',56),b=[P];function B(M,T){return e(),o("div",null,b)}const k=t(x,[["render",B],["__file","springcloudgateway.html.vue"]]),E=JSON.parse('{"path":"/spring/springcloud/springcloudgateway.html","title":"SpringCloudGateway","lang":"zh-CN","frontmatter":{"description":"SpringCloudGateway 路由装配过程 路由配置主要使用yml配置文件和编码两种形式，在实际使用中，这种静态方式的路由配置可能无法满足需求，需要实现动态路由； 从路由装配的过程看看能否实现动态路由 静态路由的配置对象RouteDefinition 项目启动，加载GatewayAutoConfiguration时，注册一个Properties...","head":[["meta",{"property":"og:url","content":"https://glory-study-review.github.io/studynote/studynote/spring/springcloud/springcloudgateway.html"}],["meta",{"property":"og:site_name","content":"Glory学习笔记"}],["meta",{"property":"og:title","content":"SpringCloudGateway"}],["meta",{"property":"og:description","content":"SpringCloudGateway 路由装配过程 路由配置主要使用yml配置文件和编码两种形式，在实际使用中，这种静态方式的路由配置可能无法满足需求，需要实现动态路由； 从路由装配的过程看看能否实现动态路由 静态路由的配置对象RouteDefinition 项目启动，加载GatewayAutoConfiguration时，注册一个Properties..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-09T13:35:23.000Z"}],["meta",{"property":"article:author","content":"Glory"}],["meta",{"property":"article:modified_time","content":"2024-07-09T13:35:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"SpringCloudGateway\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-09T13:35:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Glory\\"}]}"]]},"headers":[{"level":2,"title":"路由装配过程","slug":"路由装配过程","link":"#路由装配过程","children":[]}],"git":{"createdTime":1716367059000,"updatedTime":1720532123000,"contributors":[{"name":"Glory","email":"214521739@qq.com","commits":2}]},"readingTime":{"minutes":3.03,"words":910},"filePathRelative":"spring/springcloud/springcloudgateway.md","localizedDate":"2024年5月22日","autoDesc":true,"excerpt":"\\n<h2>路由装配过程</h2>\\n<blockquote>\\n<p>路由配置主要使用yml配置文件和编码两种形式，在实际使用中，这种静态方式的路由配置可能无法满足需求，需要实现动态路由；</p>\\n<p>从路由装配的过程看看能否实现动态路由</p>\\n</blockquote>\\n<p>静态路由的配置对象<code>RouteDefinition</code></p>\\n<p></p>\\n<p>项目启动，加载<code>GatewayAutoConfiguration</code>时，注册一个<code>PropertiesRouteDefinitionLocator</code>类将网关配置文件信息加载到内存中</p>"}');export{k as comp,E as data};
